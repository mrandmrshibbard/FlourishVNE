/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: npm run generate:engine-bundle
 * Source: dist-standalone/game-engine.js
 * Size: 237.49 KB
 */

export const GAME_ENGINE_BUNDLE = `var GameEngine = (function(exports, jsxRuntime2, React2, ReactDOM2) {
  "use strict";
  const projectReducer = (state, action) => {
    switch (action.type) {
      case "SET_PROJECT":
        return action.payload;
      case "UPDATE_PROJECT_TITLE": {
        return {
          ...state,
          title: action.payload.title
        };
      }
      default:
        if (action && action.type && !action.type.startsWith("UPDATE_PROJECT_")) {
          return state;
        }
        return state;
    }
  };
  var CommandType = /* @__PURE__ */ ((CommandType2) => {
    CommandType2["Dialogue"] = "Dialogue";
    CommandType2["SetBackground"] = "SetBackground";
    CommandType2["ShowCharacter"] = "ShowCharacter";
    CommandType2["HideCharacter"] = "HideCharacter";
    CommandType2["Choice"] = "Choice";
    CommandType2["BranchStart"] = "BranchStart";
    CommandType2["BranchEnd"] = "BranchEnd";
    CommandType2["SetVariable"] = "SetVariable";
    CommandType2["TextInput"] = "TextInput";
    CommandType2["Jump"] = "Jump";
    CommandType2["Label"] = "Label";
    CommandType2["JumpToLabel"] = "JumpToLabel";
    CommandType2["PlayMusic"] = "PlayMusic";
    CommandType2["StopMusic"] = "StopMusic";
    CommandType2["PlaySoundEffect"] = "PlaySoundEffect";
    CommandType2["PlayMovie"] = "PlayMovie";
    CommandType2["Wait"] = "Wait";
    CommandType2["ShakeScreen"] = "ShakeScreen";
    CommandType2["TintScreen"] = "TintScreen";
    CommandType2["PanZoomScreen"] = "PanZoomScreen";
    CommandType2["ResetScreenEffects"] = "ResetScreenEffects";
    CommandType2["FlashScreen"] = "FlashScreen";
    CommandType2["ShowScreen"] = "ShowScreen";
    CommandType2["ShowText"] = "ShowText";
    CommandType2["ShowImage"] = "ShowImage";
    CommandType2["HideText"] = "HideText";
    CommandType2["HideImage"] = "HideImage";
    CommandType2["ShowButton"] = "ShowButton";
    CommandType2["HideButton"] = "HideButton";
    CommandType2["Group"] = "Group";
    return CommandType2;
  })(CommandType || {});
  const assetReducer = (state, action) => {
    switch (action.type) {
      case "ADD_ASSET": {
        const { assetType, asset } = action.payload;
        console.log("[assetReducer] ADD_ASSET:", { assetType, assetId: asset.id, assetName: asset.name });
        console.log("[assetReducer] Current state[assetType]:", state[assetType]);
        const newState = {
          ...state,
          [assetType]: {
            ...state[assetType],
            [asset.id]: asset
          }
        };
        console.log("[assetReducer] New state[assetType]:", newState[assetType]);
        return newState;
      }
      case "UPDATE_ASSET": {
        const { assetType, assetId, updates } = action.payload;
        const asset = state[assetType][assetId];
        if (!asset) return state;
        return {
          ...state,
          [assetType]: {
            ...state[assetType],
            [assetId]: { ...asset, ...updates }
          }
        };
      }
      case "DELETE_ASSET": {
        const { assetType, assetId } = action.payload;
        const { [assetId]: _, ...remainingAssets } = state[assetType];
        const fallbackId = Object.keys(remainingAssets)[0];
        let newState = { ...state, [assetType]: remainingAssets };
        if (fallbackId) {
          const newScenes = JSON.parse(JSON.stringify(state.scenes));
          for (const sceneId in newScenes) {
            newScenes[sceneId].commands = newScenes[sceneId].commands.map((cmd) => {
              if (assetType === "backgrounds" && cmd.type === CommandType.SetBackground && cmd.backgroundId === assetId) {
                return { ...cmd, backgroundId: fallbackId };
              }
              if (assetType === "images" && cmd.type === CommandType.ShowImage && cmd.imageId === assetId) {
                return { ...cmd, imageId: fallbackId };
              }
              if (assetType === "audio" && (cmd.type === CommandType.PlayMusic || cmd.type === CommandType.PlaySoundEffect) && cmd.audioId === assetId) {
                return { ...cmd, audioId: fallbackId };
              }
              if (assetType === "videos" && cmd.type === CommandType.PlayMovie && cmd.videoId === assetId) {
                return { ...cmd, videoId: fallbackId };
              }
              return cmd;
            });
          }
          newState.scenes = newScenes;
        }
        return newState;
      }
      default:
        return state;
    }
  };
  const generateId\$4 = () => Math.random().toString(36).substring(2, 9);
  const characterReducer = (state, action) => {
    var _a;
    switch (action.type) {
      case "ADD_CHARACTER": {
        const { name, color } = action.payload;
        const newId = \`char-\${generateId\$4()}\`;
        const newExprId = \`expr-\${generateId\$4()}\`;
        const newExpression = { id: newExprId, name: "Default", layerConfiguration: {} };
        const newCharacter = {
          id: newId,
          name,
          color,
          baseImageUrl: null,
          layers: {},
          expressions: { [newExprId]: newExpression }
        };
        return {
          ...state,
          characters: {
            ...state.characters,
            [newId]: newCharacter
          }
        };
      }
      case "DELETE_CHARACTER": {
        const { characterId } = action.payload;
        const { [characterId]: _, ...remaining } = state.characters;
        const fallbackId = Object.keys(remaining)[0];
        const newScenes = JSON.parse(JSON.stringify(state.scenes));
        for (const sceneId in newScenes) {
          newScenes[sceneId].commands = newScenes[sceneId].commands.map((cmd) => {
            if (cmd.type === CommandType.Dialogue && cmd.characterId === characterId) {
              return { ...cmd, characterId: null };
            }
            if ((cmd.type === CommandType.ShowCharacter || cmd.type === CommandType.HideCharacter) && cmd.characterId === characterId) {
              if (fallbackId) {
                return { ...cmd, characterId: fallbackId };
              }
            }
            return cmd;
          }).filter(Boolean);
        }
        return {
          ...state,
          characters: remaining,
          scenes: newScenes
        };
      }
      case "UPDATE_CHARACTER": {
        const { characterId, updates } = action.payload;
        const character = state.characters[characterId];
        if (!character) return state;
        const updatedCharacter = { ...character, ...updates };
        return {
          ...state,
          characters: {
            ...state.characters,
            [characterId]: updatedCharacter
          }
        };
      }
      case "ADD_CHARACTER_LAYER": {
        const { characterId, name } = action.payload;
        const character = state.characters[characterId];
        if (!character) return state;
        const newLayerId = \`layer-\${generateId\$4()}\`;
        const newLayer = { id: newLayerId, name, assets: {} };
        const newLayers = { ...character.layers, [newLayerId]: newLayer };
        return { ...state, characters: { ...state.characters, [characterId]: { ...character, layers: newLayers } } };
      }
      case "UPDATE_CHARACTER_LAYER": {
        const { characterId, layerId, name } = action.payload;
        const character = state.characters[characterId];
        if (!(character == null ? void 0 : character.layers[layerId])) return state;
        const updatedLayer = { ...character.layers[layerId], name };
        const newLayers = { ...character.layers, [layerId]: updatedLayer };
        return { ...state, characters: { ...state.characters, [characterId]: { ...character, layers: newLayers } } };
      }
      case "DELETE_CHARACTER_LAYER": {
        const { characterId, layerId } = action.payload;
        const character = state.characters[characterId];
        if (!character) return state;
        const { [layerId]: _, ...remainingLayers } = character.layers;
        const newExpressions = { ...character.expressions };
        for (const exprId in newExpressions) {
          delete newExpressions[exprId].layerConfiguration[layerId];
        }
        return { ...state, characters: { ...state.characters, [characterId]: { ...character, layers: remainingLayers, expressions: newExpressions } } };
      }
      case "ADD_LAYER_ASSET": {
        const { characterId, layerId, name, imageUrl, videoUrl, isVideo, loop, autoplay } = action.payload;
        const character = state.characters[characterId];
        if (!(character == null ? void 0 : character.layers[layerId])) return state;
        const newAssetId = \`asset-\${generateId\$4()}\`;
        const newAsset = {
          id: newAssetId,
          name,
          imageUrl,
          videoUrl,
          isVideo,
          loop,
          autoplay
        };
        const newAssets = { ...character.layers[layerId].assets, [newAssetId]: newAsset };
        const newLayers = { ...character.layers, [layerId]: { ...character.layers[layerId], assets: newAssets } };
        return { ...state, characters: { ...state.characters, [characterId]: { ...character, layers: newLayers } } };
      }
      case "DELETE_LAYER_ASSET": {
        const { characterId, layerId, assetId } = action.payload;
        const character = state.characters[characterId];
        if (!((_a = character == null ? void 0 : character.layers[layerId]) == null ? void 0 : _a.assets[assetId])) return state;
        const { [assetId]: _, ...remainingAssets } = character.layers[layerId].assets;
        const newLayers = { ...character.layers, [layerId]: { ...character.layers[layerId], assets: remainingAssets } };
        const newExpressions = { ...character.expressions };
        for (const exprId in newExpressions) {
          if (newExpressions[exprId].layerConfiguration[layerId] === assetId) {
            newExpressions[exprId].layerConfiguration[layerId] = null;
          }
        }
        return { ...state, characters: { ...state.characters, [characterId]: { ...character, layers: newLayers, expressions: newExpressions } } };
      }
      case "ADD_EXPRESSION": {
        const { characterId, name } = action.payload;
        const character = state.characters[characterId];
        if (!character) return state;
        const newExprId = \`expr-\${generateId\$4()}\`;
        const newExpression = { id: newExprId, name, layerConfiguration: {} };
        Object.keys(character.layers).forEach((layerId) => {
          newExpression.layerConfiguration[layerId] = null;
        });
        const newExpressions = { ...character.expressions, [newExprId]: newExpression };
        return { ...state, characters: { ...state.characters, [characterId]: { ...character, expressions: newExpressions } } };
      }
      case "UPDATE_EXPRESSION": {
        const { characterId, expressionId, updates } = action.payload;
        const character = state.characters[characterId];
        if (!(character == null ? void 0 : character.expressions[expressionId])) return state;
        const newExpression = { ...character.expressions[expressionId], ...updates };
        const newExpressions = { ...character.expressions, [expressionId]: newExpression };
        return { ...state, characters: { ...state.characters, [characterId]: { ...character, expressions: newExpressions } } };
      }
      case "DELETE_EXPRESSION": {
        const { characterId, expressionId } = action.payload;
        const character = state.characters[characterId];
        if (!character) return state;
        const { [expressionId]: _, ...remainingExpressions } = character.expressions;
        const newScenes = JSON.parse(JSON.stringify(state.scenes));
        const firstExprId = Object.keys(remainingExpressions)[0];
        for (const sceneId in newScenes) {
          newScenes[sceneId].commands.forEach((cmd) => {
            if (cmd.type === CommandType.ShowCharacter && cmd.expressionId === expressionId) {
              cmd.expressionId = firstExprId || "";
            }
          });
        }
        return { ...state, scenes: newScenes, characters: { ...state.characters, [characterId]: { ...character, expressions: remainingExpressions } } };
      }
      default:
        return state;
    }
  };
  var UIActionType = /* @__PURE__ */ ((UIActionType2) => {
    UIActionType2["None"] = "None";
    UIActionType2["StartNewGame"] = "StartNewGame";
    UIActionType2["GoToScreen"] = "GoToScreen";
    UIActionType2["LoadGame"] = "LoadGame";
    UIActionType2["SaveGame"] = "SaveGame";
    UIActionType2["ReturnToGame"] = "ReturnToGame";
    UIActionType2["ReturnToPreviousScreen"] = "ReturnToPreviousScreen";
    UIActionType2["QuitToTitle"] = "QuitToTitle";
    UIActionType2["ExitGame"] = "ExitGame";
    UIActionType2["JumpToScene"] = "JumpToScene";
    UIActionType2["SetVariable"] = "SetVariable";
    UIActionType2["CycleLayerAsset"] = "CycleLayerAsset";
    UIActionType2["ToggleScreen"] = "ToggleScreen";
    return UIActionType2;
  })(UIActionType || {});
  const generateId\$3 = () => Math.random().toString(36).substring(2, 9);
  const sceneReducer = (state, action) => {
    switch (action.type) {
      case "ADD_SCENE": {
        const newId = \`scene-\${generateId\$3()}\`;
        const newScene = { id: newId, name: action.payload.name, commands: [] };
        return {
          ...state,
          scenes: { ...state.scenes, [newId]: newScene }
        };
      }
      case "UPDATE_SCENE": {
        const { sceneId, name } = action.payload;
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...state.scenes[sceneId], name } }
        };
      }
      case "UPDATE_SCENE_CONFIG": {
        const { sceneId, updates } = action.payload;
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...state.scenes[sceneId], ...updates } }
        };
      }
      case "DELETE_SCENE": {
        const { sceneId } = action.payload;
        if (Object.keys(state.scenes).length <= 1) return state;
        const { [sceneId]: _, ...remainingScenes } = state.scenes;
        let newStartSceneId = state.startSceneId;
        if (state.startSceneId === sceneId) {
          newStartSceneId = Object.keys(remainingScenes)[0] || "";
        }
        for (const sId in remainingScenes) {
          remainingScenes[sId].commands = remainingScenes[sId].commands.map((cmd) => {
            if (cmd.type === CommandType.Jump && cmd.targetSceneId === sceneId) {
              return { ...cmd, targetSceneId: newStartSceneId };
            }
            if (cmd.type === CommandType.Choice) {
              const choiceCmd = cmd;
              const newOptions = choiceCmd.options.map((opt) => {
                if (opt.targetSceneId === sceneId) {
                  return { ...opt, targetSceneId: newStartSceneId };
                }
                if (opt.actions) {
                  const newActions = opt.actions.map((action2) => {
                    if (action2.type === UIActionType.JumpToScene && action2.targetSceneId === sceneId) {
                      return { ...action2, targetSceneId: newStartSceneId };
                    }
                    return action2;
                  });
                  return { ...opt, actions: newActions };
                }
                return opt;
              });
              return { ...cmd, options: newOptions };
            }
            return cmd;
          });
        }
        return {
          ...state,
          scenes: remainingScenes,
          startSceneId: newStartSceneId
        };
      }
      case "DUPLICATE_SCENE": {
        const { sceneId } = action.payload;
        const originalScene = state.scenes[sceneId];
        if (!originalScene) return state;
        const newId = \`scene-\${generateId\$3()}\`;
        const duplicatedScene = {
          ...originalScene,
          id: newId,
          name: \`\${originalScene.name} (Copy)\`,
          commands: originalScene.commands.map((cmd) => ({ ...cmd, id: \`cmd-\${generateId\$3()}\` }))
        };
        return {
          ...state,
          scenes: { ...state.scenes, [newId]: duplicatedScene }
        };
      }
      case "REORDER_SCENES": {
        const { sceneIds } = action.payload;
        const newScenes = {};
        sceneIds.forEach((id) => {
          if (state.scenes[id]) {
            newScenes[id] = state.scenes[id];
          }
        });
        return {
          ...state,
          scenes: newScenes
        };
      }
      case "SET_START_SCENE": {
        return { ...state, startSceneId: action.payload.sceneId };
      }
      case "UPDATE_SCENE_COMMANDS": {
        const { sceneId, commands } = action.payload;
        return {
          ...state,
          scenes: {
            ...state.scenes,
            [sceneId]: {
              ...state.scenes[sceneId],
              commands
            }
          }
        };
      }
      case "ADD_COMMAND": {
        const { sceneId, command } = action.payload;
        const scene = state.scenes[sceneId];
        const newCommands = [...scene.commands, { ...command, id: \`cmd-\${generateId\$3()}\` }];
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      case "UPDATE_COMMAND": {
        const { sceneId, commandIndex, command } = action.payload;
        const scene = state.scenes[sceneId];
        const newCommands = [...scene.commands];
        newCommands[commandIndex] = command;
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      case "DELETE_COMMAND": {
        const { sceneId, commandIndex } = action.payload;
        const scene = state.scenes[sceneId];
        const commandToDelete = scene.commands[commandIndex];
        if ((commandToDelete == null ? void 0 : commandToDelete.type) === CommandType.BranchStart) {
          const branchCmd = commandToDelete;
          const branchEndIndex = scene.commands.findIndex(
            (cmd, i) => i > commandIndex && cmd.type === CommandType.BranchEnd && cmd.branchId === branchCmd.branchId
          );
          if (branchEndIndex !== -1) {
            const newCommands2 = scene.commands.filter(
              (_, i) => i !== commandIndex && i !== branchEndIndex
            );
            return {
              ...state,
              scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands2 } }
            };
          }
        }
        if ((commandToDelete == null ? void 0 : commandToDelete.type) === CommandType.BranchEnd) {
          return state;
        }
        const newCommands = scene.commands.filter((_, index) => index !== commandIndex);
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      case "MOVE_COMMAND": {
        const { sceneId, fromIndex, toIndex } = action.payload;
        if (fromIndex === toIndex) return state;
        const scene = state.scenes[sceneId];
        const newCommands = [...scene.commands];
        const movedCommand = newCommands[fromIndex];
        if (movedCommand.type === CommandType.BranchStart) {
          const branchCmd = movedCommand;
          const branchEndIndex = newCommands.findIndex(
            (cmd, i) => i > fromIndex && cmd.type === CommandType.BranchEnd && cmd.branchId === branchCmd.branchId
          );
          if (branchEndIndex !== -1) {
            const branchLength = branchEndIndex - fromIndex + 1;
            const branchCommands = newCommands.splice(fromIndex, branchLength);
            let adjustedToIndex = toIndex;
            if (toIndex > fromIndex) {
              adjustedToIndex -= branchLength;
            }
            newCommands.splice(adjustedToIndex, 0, ...branchCommands);
            return {
              ...state,
              scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
            };
          }
        }
        if (movedCommand.type === CommandType.BranchEnd) {
          return state;
        }
        const [removed] = newCommands.splice(fromIndex, 1);
        newCommands.splice(toIndex, 0, removed);
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      case "TOGGLE_GROUP_COLLAPSE": {
        const { sceneId, groupId } = action.payload;
        const scene = state.scenes[sceneId];
        const newCommands = scene.commands.map((cmd) => {
          if (cmd.id === groupId && cmd.type === CommandType.Group) {
            return { ...cmd, collapsed: !cmd.collapsed };
          }
          return cmd;
        });
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      case "ADD_COMMAND_TO_GROUP": {
        const { sceneId, groupId, commandId } = action.payload;
        const scene = state.scenes[sceneId];
        const newCommands = scene.commands.map((cmd) => {
          if (cmd.id === groupId && cmd.type === CommandType.Group) {
            const groupCmd = cmd;
            return { ...groupCmd, commandIds: [...groupCmd.commandIds || [], commandId] };
          }
          return cmd;
        });
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      case "REMOVE_COMMAND_FROM_GROUP": {
        const { sceneId, groupId, commandId } = action.payload;
        const scene = state.scenes[sceneId];
        const newCommands = scene.commands.map((cmd) => {
          if (cmd.id === groupId && cmd.type === CommandType.Group) {
            const groupCmd = cmd;
            return { ...groupCmd, commandIds: (groupCmd.commandIds || []).filter((id) => id !== commandId) };
          }
          return cmd;
        });
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      case "RENAME_GROUP": {
        const { sceneId, groupId, name } = action.payload;
        const scene = state.scenes[sceneId];
        const newCommands = scene.commands.map((cmd) => {
          if (cmd.id === groupId && cmd.type === CommandType.Group) {
            const groupCmd = cmd;
            return { ...groupCmd, name };
          }
          return cmd;
        });
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      case "REORDER_COMMANDS_IN_GROUP": {
        const { sceneId, groupId, commandIds } = action.payload;
        const scene = state.scenes[sceneId];
        const newCommands = scene.commands.map((cmd) => {
          if (cmd.id === groupId && cmd.type === CommandType.Group) {
            const groupCmd = cmd;
            return { ...groupCmd, commandIds };
          }
          return cmd;
        });
        return {
          ...state,
          scenes: { ...state.scenes, [sceneId]: { ...scene, commands: newCommands } }
        };
      }
      default:
        return state;
    }
  };
  var UIElementType = /* @__PURE__ */ ((UIElementType2) => {
    UIElementType2["Button"] = "Button";
    UIElementType2["Text"] = "Text";
    UIElementType2["Image"] = "Image";
    UIElementType2["SaveSlotGrid"] = "SaveSlotGrid";
    UIElementType2["SettingsSlider"] = "SettingsSlider";
    UIElementType2["SettingsToggle"] = "SettingsToggle";
    UIElementType2["CharacterPreview"] = "CharacterPreview";
    UIElementType2["TextInput"] = "TextInput";
    UIElementType2["Dropdown"] = "Dropdown";
    UIElementType2["Checkbox"] = "Checkbox";
    return UIElementType2;
  })(UIElementType || {});
  const generateId\$2 = (prefix) => \`\${prefix}-\${Math.random().toString(36).substring(2, 9)}\`;
  const createDefaultUIScreens = () => {
    const titleScreenId = generateId\$2("screen");
    const saveScreenId = generateId\$2("screen");
    const loadScreenId = generateId\$2("screen");
    const settingsScreenId = generateId\$2("screen");
    const pauseScreenId = generateId\$2("screen");
    const defaultFont = { family: "Poppins, sans-serif", size: 24, color: "#f0e6ff", weight: "normal", italic: false };
    const titleFont = { family: "Poppins, sans-serif", size: 64, color: "#f0e6ff", weight: "bold", italic: false };
    const headerFont = { family: "Poppins, sans-serif", size: 48, color: "#f0e6ff", weight: "bold", italic: false };
    const titleScreenElements = {};
    const titleTextId = generateId\$2("el");
    titleScreenElements[titleTextId] = { id: titleTextId, name: "Title Text", type: UIElementType.Text, text: "My Visual Novel", x: 50, y: 30, width: 60, height: 15, anchorX: 0.5, anchorY: 0.5, font: titleFont, textAlign: "center", verticalAlign: "middle" };
    const newGameBtnId = generateId\$2("el");
    titleScreenElements[newGameBtnId] = { id: newGameBtnId, name: "New Game Button", type: UIElementType.Button, text: "New Game", x: 50, y: 55, width: 20, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.StartNewGame }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const loadGameBtnId = generateId\$2("el");
    titleScreenElements[loadGameBtnId] = { id: loadGameBtnId, name: "Load Game Button", type: UIElementType.Button, text: "Load Game", x: 50, y: 65, width: 20, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.GoToScreen, targetScreenId: loadScreenId }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const settingsBtnId = generateId\$2("el");
    titleScreenElements[settingsBtnId] = { id: settingsBtnId, name: "Settings Button", type: UIElementType.Button, text: "Settings", x: 50, y: 75, width: 20, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.GoToScreen, targetScreenId: settingsScreenId }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const saveScreenElements = {};
    const saveHeaderId = generateId\$2("el");
    saveScreenElements[saveHeaderId] = { id: saveHeaderId, name: "Header", type: UIElementType.Text, text: "Save Game", x: 50, y: 10, width: 60, height: 10, anchorX: 0.5, anchorY: 0.5, font: headerFont, textAlign: "center", verticalAlign: "middle" };
    const saveGridId = generateId\$2("el");
    saveScreenElements[saveGridId] = { id: saveGridId, name: "Save Slots", type: UIElementType.SaveSlotGrid, slotCount: 8, font: defaultFont, emptySlotText: "[ Empty Slot ]", x: 50, y: 50, width: 80, height: 65, anchorX: 0.5, anchorY: 0.5 };
    const saveBackBtnId = generateId\$2("el");
    saveScreenElements[saveBackBtnId] = { id: saveBackBtnId, name: "Back Button", type: UIElementType.Button, text: "Back", x: 50, y: 90, width: 20, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.ReturnToPreviousScreen }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const loadScreenElements = {};
    const loadHeaderId = generateId\$2("el");
    loadScreenElements[loadHeaderId] = { id: loadHeaderId, name: "Header", type: UIElementType.Text, text: "Load Game", x: 50, y: 10, width: 60, height: 10, anchorX: 0.5, anchorY: 0.5, font: headerFont, textAlign: "center", verticalAlign: "middle" };
    const loadGridId = generateId\$2("el");
    loadScreenElements[loadGridId] = { id: loadGridId, name: "Load Slots", type: UIElementType.SaveSlotGrid, slotCount: 8, font: defaultFont, emptySlotText: "[ Empty Slot ]", x: 50, y: 50, width: 80, height: 65, anchorX: 0.5, anchorY: 0.5 };
    const loadBackBtnId = generateId\$2("el");
    loadScreenElements[loadBackBtnId] = { id: loadBackBtnId, name: "Back Button", type: UIElementType.Button, text: "Back", x: 50, y: 90, width: 20, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.ReturnToPreviousScreen }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const settingsScreenElements = {};
    const settingsHeaderId = generateId\$2("el");
    settingsScreenElements[settingsHeaderId] = { id: settingsHeaderId, name: "Header", type: UIElementType.Text, text: "Settings", x: 50, y: 10, width: 60, height: 10, anchorX: 0.5, anchorY: 0.5, font: headerFont, textAlign: "center", verticalAlign: "middle" };
    const musicLabelId = generateId\$2("el");
    settingsScreenElements[musicLabelId] = { id: musicLabelId, name: "Music Volume Label", type: UIElementType.Text, text: "Music Volume", x: 35, y: 30, width: 20, height: 5, anchorX: 0.5, anchorY: 0.5, font: defaultFont, textAlign: "left", verticalAlign: "middle" };
    const musicSliderId = generateId\$2("el");
    settingsScreenElements[musicSliderId] = { id: musicSliderId, name: "Music Volume Slider", type: UIElementType.SettingsSlider, setting: "musicVolume", x: 65, y: 30, width: 40, height: 5, anchorX: 0.5, anchorY: 0.5 };
    const sfxLabelId = generateId\$2("el");
    settingsScreenElements[sfxLabelId] = { id: sfxLabelId, name: "SFX Volume Label", type: UIElementType.Text, text: "Sound FX Volume", x: 35, y: 40, width: 20, height: 5, anchorX: 0.5, anchorY: 0.5, font: defaultFont, textAlign: "left", verticalAlign: "middle" };
    const sfxSliderId = generateId\$2("el");
    settingsScreenElements[sfxSliderId] = { id: sfxSliderId, name: "SFX Volume Slider", type: UIElementType.SettingsSlider, setting: "sfxVolume", x: 65, y: 40, width: 40, height: 5, anchorX: 0.5, anchorY: 0.5 };
    const textSpeedLabelId = generateId\$2("el");
    settingsScreenElements[textSpeedLabelId] = { id: textSpeedLabelId, name: "Text Speed Label", type: UIElementType.Text, text: "Text Speed", x: 35, y: 50, width: 20, height: 5, anchorX: 0.5, anchorY: 0.5, font: defaultFont, textAlign: "left", verticalAlign: "middle" };
    const textSpeedSliderId = generateId\$2("el");
    settingsScreenElements[textSpeedSliderId] = { id: textSpeedSliderId, name: "Text Speed Slider", type: UIElementType.SettingsSlider, setting: "textSpeed", x: 65, y: 50, width: 40, height: 5, anchorX: 0.5, anchorY: 0.5 };
    const skipToggleId = generateId\$2("el");
    settingsScreenElements[skipToggleId] = { id: skipToggleId, name: "Enable Skip Toggle", type: UIElementType.SettingsToggle, setting: "enableSkip", text: "Enable Skip", x: 50, y: 60, width: 30, height: 5, anchorX: 0.5, anchorY: 0.5, font: defaultFont };
    const backBtnId = generateId\$2("el");
    settingsScreenElements[backBtnId] = { id: backBtnId, name: "Back Button", type: UIElementType.Button, text: "Back", x: 50, y: 85, width: 20, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.ReturnToPreviousScreen }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const pauseScreenElements = {};
    const returnBtnId = generateId\$2("el");
    pauseScreenElements[returnBtnId] = { id: returnBtnId, name: "Return Button", type: UIElementType.Button, text: "Return to Game", x: 50, y: 30, width: 30, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.ReturnToGame }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const pauseSaveBtnId = generateId\$2("el");
    pauseScreenElements[pauseSaveBtnId] = { id: pauseSaveBtnId, name: "Save Game Button", type: UIElementType.Button, text: "Save Game", x: 50, y: 40, width: 30, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.GoToScreen, targetScreenId: saveScreenId }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const pauseLoadBtnId = generateId\$2("el");
    pauseScreenElements[pauseLoadBtnId] = { id: pauseLoadBtnId, name: "Load Game Button", type: UIElementType.Button, text: "Load Game", x: 50, y: 50, width: 30, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.GoToScreen, targetScreenId: loadScreenId }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const pauseSettingsBtnId = generateId\$2("el");
    pauseScreenElements[pauseSettingsBtnId] = { id: pauseSettingsBtnId, name: "Settings Button", type: UIElementType.Button, text: "Settings", x: 50, y: 60, width: 30, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.GoToScreen, targetScreenId: settingsScreenId }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const pauseQuitBtnId = generateId\$2("el");
    pauseScreenElements[pauseQuitBtnId] = { id: pauseQuitBtnId, name: "Quit Button", type: UIElementType.Button, text: "Quit to Title", x: 50, y: 70, width: 30, height: 8, anchorX: 0.5, anchorY: 0.5, font: defaultFont, action: { type: UIActionType.QuitToTitle }, image: null, hoverImage: null, clickSoundId: null, hoverSoundId: null };
    const screens = {
      [titleScreenId]: {
        id: titleScreenId,
        name: "Title Screen",
        background: { type: "color", value: "#1a102c" },
        music: { audioId: null, policy: "continue" },
        ambientNoise: { audioId: null, policy: "continue" },
        elements: titleScreenElements
      },
      [saveScreenId]: { id: saveScreenId, name: "Save Screen", background: { type: "color", value: "#1a102c" }, music: { audioId: null, policy: "continue" }, ambientNoise: { audioId: null, policy: "continue" }, elements: saveScreenElements },
      [loadScreenId]: { id: loadScreenId, name: "Load Screen", background: { type: "color", value: "#1a102c" }, music: { audioId: null, policy: "continue" }, ambientNoise: { audioId: null, policy: "continue" }, elements: loadScreenElements },
      [settingsScreenId]: {
        id: settingsScreenId,
        name: "Settings Screen",
        background: { type: "color", value: "#1a102c" },
        music: { audioId: null, policy: "continue" },
        ambientNoise: { audioId: null, policy: "continue" },
        elements: settingsScreenElements
      },
      [pauseScreenId]: {
        id: pauseScreenId,
        name: "Pause Menu",
        background: { type: "color", value: "#1a102c" },
        music: { audioId: null, policy: "continue" },
        ambientNoise: { audioId: null, policy: "continue" },
        elements: pauseScreenElements
      }
    };
    const specialIds = { titleScreenId, saveScreenId, loadScreenId, settingsScreenId, pauseScreenId };
    return { screens, specialIds };
  };
  const generateId\$1 = () => Math.random().toString(36).substring(2, 9);
  const uiReducer = (state, action) => {
    switch (action.type) {
      case "UPDATE_UI": {
        return {
          ...state,
          ui: {
            ...state.ui,
            ...action.payload
          }
        };
      }
      case "UPDATE_UI_CONFIG": {
        const { key, value } = action.payload;
        return {
          ...state,
          ui: {
            ...state.ui,
            [key]: value
          }
        };
      }
      case "UPDATE_UI_FONT_CONFIG": {
        const { target, property, value } = action.payload;
        return {
          ...state,
          ui: {
            ...state.ui,
            [target]: {
              ...state.ui[target],
              [property]: value
            }
          }
        };
      }
      case "RESTORE_DEFAULT_UI_SCREENS": {
        const { screens: defaultScreens, specialIds } = createDefaultUIScreens();
        return {
          ...state,
          uiScreens: {
            ...state.uiScreens,
            ...defaultScreens
          },
          ui: {
            ...state.ui,
            titleScreenId: specialIds.titleScreenId,
            settingsScreenId: specialIds.settingsScreenId,
            saveScreenId: specialIds.saveScreenId,
            loadScreenId: specialIds.loadScreenId,
            pauseScreenId: specialIds.pauseScreenId
          }
        };
      }
      case "ADD_UI_SCREEN": {
        const { name } = action.payload;
        const newId = \`screen-\${generateId\$1()}\`;
        const newScreen = {
          id: newId,
          name,
          background: { type: "color", value: "#0f172a" },
          music: { audioId: null, policy: "continue" },
          ambientNoise: { audioId: null, policy: "continue" },
          elements: {}
        };
        return { ...state, uiScreens: { ...state.uiScreens, [newId]: newScreen } };
      }
      case "UPDATE_UI_SCREEN": {
        const { screenId, updates } = action.payload;
        const screen = state.uiScreens[screenId];
        if (!screen) return state;
        return { ...state, uiScreens: { ...state.uiScreens, [screenId]: { ...screen, ...updates } } };
      }
      case "DELETE_UI_SCREEN": {
        const { screenId } = action.payload;
        const specialScreenIds = [
          state.ui.titleScreenId,
          state.ui.settingsScreenId,
          state.ui.saveScreenId,
          state.ui.loadScreenId,
          state.ui.pauseScreenId
        ];
        if (specialScreenIds.includes(screenId)) {
          console.warn(\`Attempted to delete a special UI screen (\${screenId}), which is not allowed.\`);
          return state;
        }
        const { [screenId]: _, ...remainingScreens } = state.uiScreens;
        const newUiConfig = { ...state.ui };
        let uiConfigChanged = false;
        if (state.ui.titleScreenId === screenId) {
          newUiConfig.titleScreenId = null;
          uiConfigChanged = true;
        }
        if (state.ui.settingsScreenId === screenId) {
          newUiConfig.settingsScreenId = null;
          uiConfigChanged = true;
        }
        if (state.ui.saveScreenId === screenId) {
          newUiConfig.saveScreenId = null;
          uiConfigChanged = true;
        }
        if (state.ui.loadScreenId === screenId) {
          newUiConfig.loadScreenId = null;
          uiConfigChanged = true;
        }
        const cleanedScreens = Object.keys(remainingScreens).reduce((acc, sId) => {
          const screen = remainingScreens[sId];
          let screenModified = false;
          const newElements = Object.keys(screen.elements).reduce((elAcc, elId) => {
            const element = screen.elements[elId];
            if (element.type === UIElementType.Button) {
              const buttonAction = element.action;
              if (buttonAction.type === UIActionType.GoToScreen && buttonAction.targetScreenId === screenId) {
                elAcc[elId] = { ...element, action: { type: UIActionType.None } };
                screenModified = true;
              } else {
                elAcc[elId] = element;
              }
            } else {
              elAcc[elId] = element;
            }
            return elAcc;
          }, {});
          if (screenModified) {
            acc[sId] = { ...screen, elements: newElements };
          } else {
            acc[sId] = screen;
          }
          return acc;
        }, {});
        return {
          ...state,
          uiScreens: cleanedScreens,
          ...uiConfigChanged && { ui: newUiConfig }
        };
      }
      case "DUPLICATE_UI_SCREEN": {
        const { screenId } = action.payload;
        console.log("[DUPLICATE_UI_SCREEN] Duplicating screen:", screenId);
        const originalScreen = state.uiScreens[screenId];
        if (!originalScreen) {
          console.error("[DUPLICATE_UI_SCREEN] Screen not found:", screenId);
          return state;
        }
        const newScreenId = \`screen-\${generateId\$1()}\`;
        const newScreen = JSON.parse(JSON.stringify(originalScreen));
        newScreen.id = newScreenId;
        newScreen.name = \`Copy of \${originalScreen.name}\`;
        const newElements = {};
        for (const element of Object.values(originalScreen.elements)) {
          const newElementId = \`elem-\${generateId\$1()}\`;
          newElements[newElementId] = { ...element, id: newElementId };
        }
        newScreen.elements = newElements;
        console.log("[DUPLICATE_UI_SCREEN] Created new screen:", newScreenId, "with name:", newScreen.name);
        return {
          ...state,
          uiScreens: {
            ...state.uiScreens,
            [newScreenId]: newScreen
          }
        };
      }
      case "ADD_UI_ELEMENT": {
        const { screenId, element } = action.payload;
        const screen = state.uiScreens[screenId];
        if (!screen) return state;
        const newElements = { ...screen.elements, [element.id]: element };
        return { ...state, uiScreens: { ...state.uiScreens, [screenId]: { ...screen, elements: newElements } } };
      }
      case "UPDATE_UI_ELEMENT": {
        const { screenId, elementId, updates } = action.payload;
        const screen = state.uiScreens[screenId];
        const element = screen == null ? void 0 : screen.elements[elementId];
        if (!element) return state;
        const newElement = { ...element, ...updates };
        const newElements = { ...screen.elements, [elementId]: newElement };
        return { ...state, uiScreens: { ...state.uiScreens, [screenId]: { ...screen, elements: newElements } } };
      }
      case "DELETE_UI_ELEMENT": {
        const { screenId, elementId } = action.payload;
        const screen = state.uiScreens[screenId];
        if (!screen) return state;
        const { [elementId]: _, ...remainingElements } = screen.elements;
        return { ...state, uiScreens: { ...state.uiScreens, [screenId]: { ...screen, elements: remainingElements } } };
      }
      default:
        return state;
    }
  };
  const generateId = () => Math.random().toString(36).substring(2, 9);
  const variableReducer = (state, action) => {
    switch (action.type) {
      case "ADD_VARIABLE": {
        const newId = \`var-\${generateId()}\`;
        const newVar = { id: newId, name: action.payload.name, type: action.payload.type, defaultValue: action.payload.defaultValue };
        return {
          ...state,
          variables: { ...state.variables, [newId]: newVar }
        };
      }
      case "UPDATE_VARIABLE": {
        const { variableId, updates } = action.payload;
        return {
          ...state,
          variables: { ...state.variables, [variableId]: { ...state.variables[variableId], ...updates } }
        };
      }
      case "DELETE_VARIABLE": {
        const { variableId } = action.payload;
        const { [variableId]: _, ...remainingVars } = state.variables;
        const newScenes = { ...state.scenes };
        for (const sceneId in newScenes) {
          newScenes[sceneId].commands = newScenes[sceneId].commands.filter((cmd) => !(cmd.type === CommandType.SetVariable && cmd.variableId === variableId)).map((cmd) => {
            let newCmd = { ...cmd };
            if (newCmd.conditions) {
              const filteredConditions = newCmd.conditions.filter((c) => c.variableId !== variableId);
              if (filteredConditions.length === 0) {
                delete newCmd.conditions;
              } else {
                newCmd.conditions = filteredConditions;
              }
            }
            if (newCmd.type === CommandType.Choice) {
              const newOptions = newCmd.options.map((opt) => {
                const newOpt = { ...opt };
                if (newOpt.conditions) {
                  newOpt.conditions = newOpt.conditions.filter((c) => c.variableId !== variableId);
                  if (newOpt.conditions.length === 0) {
                    delete newOpt.conditions;
                  }
                }
                if (opt.actions) {
                  const filteredActions = opt.actions.filter((action2) => {
                    if (action2.type === UIActionType.SetVariable) {
                      return action2.variableId !== variableId;
                    }
                    return true;
                  });
                  newOpt.actions = filteredActions;
                }
                return newOpt;
              });
              return { ...newCmd, options: newOptions };
            }
            return newCmd;
          });
        }
        return {
          ...state,
          variables: remainingVars,
          scenes: newScenes
        };
      }
      default:
        return state;
    }
  };
  const reducers = [
    projectReducer,
    assetReducer,
    characterReducer,
    sceneReducer,
    uiReducer,
    variableReducer
  ];
  const rootReducer = (state, action) => {
    for (const reducer of reducers) {
      const newState = reducer(state, action);
      if (newState !== state) {
        return newState;
      }
    }
    return state;
  };
  const ProjectContext = React2.createContext(null);
  const ProjectProvider = ({ children, initialProject }) => {
    const [history, setHistory] = React2.useState({
      past: [],
      present: initialProject,
      future: []
    });
    const dispatchWithHistory = React2.useCallback((action) => {
      setHistory((prev) => {
        const newPresent = rootReducer(prev.present, action);
        if (JSON.stringify(newPresent) === JSON.stringify(prev.present)) {
          return prev;
        }
        return {
          past: [...prev.past.slice(-50 + 1), prev.present],
          present: newPresent,
          future: []
          // Clear future when new action is performed
        };
      });
    }, []);
    const undo = React2.useCallback(() => {
      setHistory((prev) => {
        if (prev.past.length === 0) return prev;
        const newPast = prev.past.slice(0, -1);
        const newPresent = prev.past[prev.past.length - 1];
        return {
          past: newPast,
          present: newPresent,
          future: [prev.present, ...prev.future]
        };
      });
    }, []);
    const redo = React2.useCallback(() => {
      setHistory((prev) => {
        if (prev.future.length === 0) return prev;
        const newFuture = prev.future.slice(1);
        const newPresent = prev.future[0];
        return {
          past: [...prev.past, prev.present],
          present: newPresent,
          future: newFuture
        };
      });
    }, []);
    React2.useEffect(() => {
      const handleKeyDown = (e) => {
        if ((e.ctrlKey || e.metaKey) && !e.shiftKey && e.key === "z") {
          e.preventDefault();
          undo();
        } else if ((e.ctrlKey || e.metaKey) && (e.shiftKey && e.key === "z" || e.key === "y")) {
          e.preventDefault();
          redo();
        }
      };
      window.addEventListener("keydown", handleKeyDown);
      return () => window.removeEventListener("keydown", handleKeyDown);
    }, [undo, redo]);
    return /* @__PURE__ */ jsxRuntime2.jsx(ProjectContext.Provider, { value: {
      project: history.present,
      dispatch: dispatchWithHistory,
      undo,
      redo,
      canUndo: history.past.length > 0,
      canRedo: history.future.length > 0
    }, children });
  };
  const useProject = () => {
    const context = React2.useContext(ProjectContext);
    if (!context) {
      throw new Error("useProject must be used within a ProjectProvider");
    }
    return context;
  };
  const interpolateVariables = (text, variables, project) => {
    if (!text) return text;
    let result = text.replace(/\\{([^}]+)\\}/g, (match, placeholder) => {
      const trimmedPlaceholder = placeholder.trim();
      const variableByName = Object.values(project.variables).find((v) => v.name === trimmedPlaceholder);
      if (variableByName) {
        const value = variables[variableByName.id];
        return value !== void 0 ? String(value) : match;
      }
      const variableById = project.variables[trimmedPlaceholder];
      if (variableById) {
        const value = variables[variableById.id];
        return value !== void 0 ? String(value) : match;
      }
      return match;
    });
    return result;
  };
  const XMarkIcon = ({ className, title, ...props }) => /* @__PURE__ */ jsxRuntime2.jsxs("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", className: \`w-5 h-5 \${className || ""}\`, ...props, children: [
    title && /* @__PURE__ */ jsxRuntime2.jsx("title", { children: title }),
    /* @__PURE__ */ jsxRuntime2.jsx("path", { d: "M6.28 5.22a.75.75 0 0 0-1.06 1.06L8.94 10l-3.72 3.72a.75.75 0 1 0 1.06 1.06L10 11.06l3.72 3.72a.75.75 0 1 0 1.06-1.06L11.06 10l3.72-3.72a.75.75 0 0 0-1.06-1.06L10 8.94 6.28 5.22Z" })
  ] });
  const fontSettingsToStyle = (settings) => ({
    fontFamily: settings.family,
    fontSize: \`\${settings.size}px\`,
    color: settings.color,
    fontWeight: settings.weight,
    fontStyle: settings.italic ? "italic" : "normal"
  });
  const defaultSettings = {
    textSpeed: 50,
    musicVolume: 0.8,
    sfxVolume: 0.8,
    enableSkip: true
  };
  const getOverlayTransitionClass = (transition, isHide) => {
    switch (transition) {
      case "fade":
        return isHide ? "transition-fade-out" : "transition-dissolve";
      case "dissolve":
        return isHide ? "transition-dissolve-out" : "transition-dissolve";
      case "slide":
        return "transition-slide";
      case "iris-in":
        return isHide ? "transition-iris-out" : "transition-iris-in";
      case "wipe-right":
        return isHide ? "transition-wipe-out-right" : "transition-wipe-right";
      default:
        return "transition-dissolve";
    }
  };
  const buildSlideStyle = (x, _y, action, stageSize) => {
    const horizontalBias = x <= 50 ? -60 : 60;
    const startPercent = action === "show" ? horizontalBias : 0;
    const endPercent = action === "hide" ? horizontalBias : 0;
    const style = {
      "--slide-start-x": \`\${startPercent}%\`,
      "--slide-start-y": \`0%\`,
      "--slide-end-x": \`\${endPercent}%\`,
      "--slide-end-y": \`0%\`
    };
    if (stageSize.width > 0 && stageSize.height > 0) {
      style["--slide-start-px"] = \`\${startPercent / 100 * stageSize.width}px\`;
      style["--slide-end-px"] = \`\${endPercent / 100 * stageSize.width}px\`;
      style["--slide-start-py"] = \`0px\`;
      style["--slide-end-py"] = \`0px\`;
    }
    return style;
  };
  const TextOverlayElement = ({ overlay, stageSize }) => {
    const hasTransition = overlay.transition && overlay.transition !== "instant";
    const [playTransition, setPlayTransition] = React2.useState(overlay.action === "hide" && !!hasTransition);
    const timeoutRef = React2.useRef(null);
    React2.useEffect(() => {
      if (timeoutRef.current !== null) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
      if (!overlay.transition || overlay.transition === "instant") {
        setPlayTransition(false);
        return;
      }
      if (overlay.action === "show") {
        setPlayTransition(false);
        timeoutRef.current = window.setTimeout(() => {
          setPlayTransition(true);
          timeoutRef.current = null;
        }, 0);
        return () => {
          if (timeoutRef.current !== null) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
          }
        };
      }
      setPlayTransition(true);
      return () => {
        if (timeoutRef.current !== null) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }
      };
    }, [overlay.id, overlay.transition, overlay.action]);
    const applyTransition = playTransition && !!hasTransition;
    const transitionClass = applyTransition && overlay.transition ? getOverlayTransitionClass(overlay.transition, overlay.action === "hide") : "";
    const animDuration = \`\${overlay.duration ?? 0.5}s\`;
    const isSlideTransition = overlay.transition === "slide";
    const slideStyle = isSlideTransition ? buildSlideStyle(overlay.x, overlay.y ?? 0, overlay.action, stageSize) : {};
    const baseStyle = {
      left: \`\${overlay.x}%\`,
      top: \`\${overlay.y}%\`,
      ...isSlideTransition ? {} : { transform: "translate(-50%, -50%)" },
      fontSize: \`\${overlay.fontSize}px\`,
      fontFamily: overlay.fontFamily,
      color: overlay.color,
      width: overlay.width ? \`\${overlay.width}px\` : "auto",
      height: overlay.height ? \`\${overlay.height}px\` : "auto",
      textAlign: overlay.textAlign || "left",
      display: "flex",
      alignItems: overlay.verticalAlign === "top" ? "flex-start" : overlay.verticalAlign === "bottom" ? "flex-end" : "center",
      justifyContent: overlay.textAlign === "left" ? "flex-start" : overlay.textAlign === "right" ? "flex-end" : "center",
      whiteSpace: overlay.width ? "pre-wrap" : "nowrap",
      overflow: "hidden"
    };
    if (overlay.action === "show" && hasTransition && !playTransition) {
      baseStyle.opacity = 0;
    }
    const className = \`absolute\${applyTransition ? \` \${transitionClass} transition-base\` : ""}\`;
    const style = {
      ...baseStyle,
      ...applyTransition ? { animationDuration: animDuration } : {},
      ...isSlideTransition ? slideStyle : {}
    };
    return /* @__PURE__ */ jsxRuntime2.jsx("div", { className, style, children: overlay.text });
  };
  const ButtonOverlayElement = ({ overlay, onAction, playSound, onAdvance }) => {
    const [isHovered, setIsHovered] = React2.useState(false);
    const hasTransition = overlay.transition && overlay.transition !== "instant";
    const [playTransition, setPlayTransition] = React2.useState(overlay.action === "hide" && !!hasTransition);
    const timeoutRef = React2.useRef(null);
    React2.useEffect(() => {
      if (timeoutRef.current !== null) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
      if (!overlay.transition || overlay.transition === "instant") {
        setPlayTransition(false);
        return;
      }
      if (overlay.action === "show") {
        setPlayTransition(false);
        timeoutRef.current = window.setTimeout(() => {
          setPlayTransition(true);
          timeoutRef.current = null;
        }, 0);
        return () => {
          if (timeoutRef.current !== null) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
          }
        };
      }
      setPlayTransition(true);
      return () => {
        if (timeoutRef.current !== null) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }
      };
    }, [overlay.id, overlay.transition, overlay.action]);
    const handleClick = () => {
      console.log("Button clicked:", overlay.text, "Action:", overlay.onClick);
      if (overlay.clickSound) {
        try {
          playSound(overlay.clickSound);
        } catch (e) {
          console.error("Error playing button click sound:", e);
        }
      }
      onAction(overlay.onClick);
      if (overlay.waitForClick && onAdvance && overlay.onClick.type !== UIActionType.JumpToScene) {
        onAdvance();
      }
    };
    const applyTransition = playTransition && overlay.transition && overlay.transition !== "instant";
    const transitionClass = applyTransition && overlay.transition ? getOverlayTransitionClass(overlay.transition, overlay.action === "hide") : "";
    const animDuration = \`\${overlay.duration ?? 0.3}s\`;
    const containerStyle = {
      position: "absolute",
      left: \`\${overlay.x}%\`,
      top: \`\${overlay.y}%\`,
      width: \`\${overlay.width}%\`,
      height: \`\${overlay.height}%\`,
      transform: \`translate(-\${overlay.anchorX * 100}%, -\${overlay.anchorY * 100}%)\`,
      pointerEvents: "auto"
    };
    if (overlay.action === "show" && hasTransition && !playTransition) {
      containerStyle.opacity = 0;
    }
    const buttonStyle = {
      width: "100%",
      height: "100%",
      backgroundColor: overlay.backgroundColor,
      color: overlay.textColor,
      fontSize: \`\${overlay.fontSize}px\`,
      fontWeight: overlay.fontWeight,
      borderRadius: \`\${overlay.borderRadius}px\`,
      border: "none",
      cursor: "pointer",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      transition: "transform 0.1s, box-shadow 0.1s",
      boxShadow: isHovered ? "0 4px 12px rgba(0,0,0,0.3)" : "0 2px 4px rgba(0,0,0,0.2)",
      transform: isHovered ? "translateY(-2px)" : "none"
    };
    const displayImage = isHovered && overlay.hoverImageUrl ? overlay.hoverImageUrl : overlay.imageUrl;
    return /* @__PURE__ */ jsxRuntime2.jsx(
      "div",
      {
        style: containerStyle,
        className: \`\${transitionClass}\`,
        ...hasTransition ? { style: { ...containerStyle, animationDuration: animDuration } } : {},
        children: /* @__PURE__ */ jsxRuntime2.jsx(
          "button",
          {
            onClick: handleClick,
            onMouseEnter: () => setIsHovered(true),
            onMouseLeave: () => setIsHovered(false),
            style: buttonStyle,
            children: displayImage ? /* @__PURE__ */ jsxRuntime2.jsx("img", { src: displayImage, alt: overlay.text, style: { width: "100%", height: "100%", objectFit: "cover", borderRadius: \`\${overlay.borderRadius}px\` } }) : /* @__PURE__ */ jsxRuntime2.jsx("span", { children: overlay.text })
          }
        )
      },
      overlay.id
    );
  };
  const ImageOverlayElement = ({ overlay, stageSize }) => {
    const hasTransition = overlay.transition && overlay.transition !== "instant";
    const [playTransition, setPlayTransition] = React2.useState(overlay.action === "hide" && !!hasTransition);
    const timeoutRef = React2.useRef(null);
    React2.useEffect(() => {
      if (timeoutRef.current !== null) {
        clearTimeout(timeoutRef.current);
        timeoutRef.current = null;
      }
      if (!overlay.transition || overlay.transition === "instant") {
        setPlayTransition(false);
        return;
      }
      if (overlay.action === "show") {
        setPlayTransition(false);
        timeoutRef.current = window.setTimeout(() => {
          setPlayTransition(true);
          timeoutRef.current = null;
        }, 0);
        return () => {
          if (timeoutRef.current !== null) {
            clearTimeout(timeoutRef.current);
            timeoutRef.current = null;
          }
        };
      }
      setPlayTransition(true);
      return () => {
        if (timeoutRef.current !== null) {
          clearTimeout(timeoutRef.current);
          timeoutRef.current = null;
        }
      };
    }, [overlay.id, overlay.transition, overlay.action]);
    const applyTransition = playTransition && overlay.transition && overlay.transition !== "instant";
    const transitionClass = applyTransition && overlay.transition ? getOverlayTransitionClass(overlay.transition, overlay.action === "hide") : "";
    const animDuration = \`\${overlay.duration ?? 0.5}s\`;
    const isSlideTransition = overlay.transition === "slide";
    const slideStyle = isSlideTransition ? buildSlideStyle(overlay.x, overlay.y ?? 0, overlay.action, stageSize) : {};
    const containerStyle = {
      left: \`\${overlay.x}%\`,
      top: \`\${overlay.y}%\`,
      width: \`\${overlay.width}px\`,
      height: \`\${overlay.height}px\`,
      ...isSlideTransition ? {} : { transform: "translate(-50%, -50%)" }
    };
    if (overlay.action === "show" && hasTransition && !playTransition) {
      containerStyle.opacity = 0;
    }
    const imageStyle = {
      width: "100%",
      height: "100%",
      transform: \`rotate(\${overlay.rotation}deg) scale(\${overlay.scaleX}, \${overlay.scaleY})\`,
      transformOrigin: "center center",
      opacity: overlay.opacity
    };
    const className = \`absolute\${applyTransition ? \` \${transitionClass} transition-base\` : ""}\`;
    const style = {
      ...containerStyle,
      ...applyTransition ? { animationDuration: animDuration } : {},
      ...isSlideTransition ? slideStyle : {}
    };
    return /* @__PURE__ */ jsxRuntime2.jsx("div", { className, style, children: overlay.isVideo && overlay.videoUrl ? /* @__PURE__ */ jsxRuntime2.jsx(
      "video",
      {
        src: overlay.videoUrl,
        autoPlay: true,
        muted: true,
        loop: overlay.videoLoop,
        playsInline: true,
        className: "absolute inset-0 w-full h-full object-contain",
        style: imageStyle
      }
    ) : /* @__PURE__ */ jsxRuntime2.jsx(
      "img",
      {
        src: overlay.imageUrl,
        alt: "",
        className: "absolute inset-0 w-full h-full object-contain",
        style: imageStyle
      }
    ) });
  };
  const useTypewriter = (text, speed) => {
    const [displayText, setDisplayText] = React2.useState("");
    const hasFinished = displayText.length === text.length;
    React2.useEffect(() => {
      setDisplayText("");
      if (!text) return;
      const interval = setInterval(() => {
        setDisplayText((prev) => {
          if (prev.length < text.length) {
            return text.substring(0, prev.length + 1);
          } else {
            clearInterval(interval);
            return prev;
          }
        });
      }, 1e3 / speed);
      return () => clearInterval(interval);
    }, [text, speed]);
    const skip = () => setDisplayText(text);
    return { displayText, skip, hasFinished };
  };
  const useStageSize = (ref) => {
    const [size, setSize] = React2.useState({ width: 0, height: 0 });
    React2.useEffect(() => {
      if (!ref.current) return;
      const el = ref.current;
      const obs = new ResizeObserver(() => {
        const r2 = el.getBoundingClientRect();
        setSize({ width: r2.width, height: r2.height });
      });
      obs.observe(el);
      const r = el.getBoundingClientRect();
      setSize({ width: r.width, height: r.height });
      return () => obs.disconnect();
    }, [ref]);
    return size;
  };
  const DialogueBox = ({ dialogue, settings, projectUI, onFinished, variables, project }) => {
    var _a, _b, _c, _d;
    if (!dialogue) return null;
    const interpolatedText = interpolateVariables(dialogue.text, variables, project);
    const { displayText, skip, hasFinished } = useTypewriter(interpolatedText, settings.textSpeed);
    const handleClick = () => {
      if (hasFinished) {
        onFinished();
      } else {
        skip();
      }
    };
    const dialogueBoxUrl = projectUI.dialogueBoxImage ? projectUI.dialogueBoxImage.type === "video" ? (_a = project.videos[projectUI.dialogueBoxImage.id]) == null ? void 0 : _a.videoUrl : ((_b = project.images[projectUI.dialogueBoxImage.id]) == null ? void 0 : _b.imageUrl) || ((_c = project.backgrounds[projectUI.dialogueBoxImage.id]) == null ? void 0 : _c.imageUrl) : null;
    const isDialogueBoxVideo = ((_d = projectUI.dialogueBoxImage) == null ? void 0 : _d.type) === "video";
    return /* @__PURE__ */ jsxRuntime2.jsxs(
      "div",
      {
        className: \`absolute bottom-5 left-5 right-5 p-5 z-20 cursor-pointer \${dialogueBoxUrl && !isDialogueBoxVideo ? "dialogue-box-custom bg-black/70" : "bg-black/70 rounded-lg border-2 border-slate-500"}\`,
        style: dialogueBoxUrl && !isDialogueBoxVideo ? { borderImageSource: \`url(\${dialogueBoxUrl})\` } : {},
        onClick: handleClick,
        children: [
          isDialogueBoxVideo && dialogueBoxUrl && /* @__PURE__ */ jsxRuntime2.jsx(
            "video",
            {
              autoPlay: true,
              loop: true,
              muted: true,
              className: "absolute inset-0 w-full h-full object-cover rounded-lg -z-10",
              style: { pointerEvents: "none" },
              children: /* @__PURE__ */ jsxRuntime2.jsx("source", { src: dialogueBoxUrl })
            }
          ),
          dialogue.characterName !== "Narrator" && /* @__PURE__ */ jsxRuntime2.jsx("h3", { className: "mb-2", style: { ...fontSettingsToStyle(projectUI.dialogueNameFont), color: dialogue.characterColor }, children: dialogue.characterName }),
          /* @__PURE__ */ jsxRuntime2.jsxs("p", { className: "leading-relaxed", style: fontSettingsToStyle(projectUI.dialogueTextFont), children: [
            displayText,
            !hasFinished && /* @__PURE__ */ jsxRuntime2.jsx("span", { className: "animate-ping", children: "_" })
          ] })
        ]
      }
    );
  };
  const ChoiceMenu = ({ choices, projectUI, onSelect, variables, project }) => {
    var _a, _b, _c, _d;
    const choiceButtonUrl = projectUI.choiceButtonImage ? projectUI.choiceButtonImage.type === "video" ? (_a = project.videos[projectUI.choiceButtonImage.id]) == null ? void 0 : _a.videoUrl : ((_b = project.images[projectUI.choiceButtonImage.id]) == null ? void 0 : _b.imageUrl) || ((_c = project.backgrounds[projectUI.choiceButtonImage.id]) == null ? void 0 : _c.imageUrl) : null;
    const isChoiceButtonVideo = ((_d = projectUI.choiceButtonImage) == null ? void 0 : _d.type) === "video";
    return /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0 bg-black/30 z-30 flex flex-col items-center justify-center p-8 space-y-4", children: choices.map((choice, index) => {
      const interpolatedText = interpolateVariables(choice.text, variables, project);
      return /* @__PURE__ */ jsxRuntime2.jsxs(
        "button",
        {
          onClick: () => onSelect(choice),
          className: \`px-8 py-4 relative \${choiceButtonUrl && !isChoiceButtonVideo ? "choice-button-custom bg-slate-800/80 hover:bg-slate-700/90" : "bg-slate-800/80 hover:bg-slate-700/90 border-2 border-slate-500 rounded-lg"}\`,
          style: choiceButtonUrl && !isChoiceButtonVideo ? { borderImageSource: \`url(\${choiceButtonUrl})\`, ...fontSettingsToStyle(projectUI.choiceTextFont) } : fontSettingsToStyle(projectUI.choiceTextFont),
          children: [
            isChoiceButtonVideo && choiceButtonUrl && /* @__PURE__ */ jsxRuntime2.jsx(
              "video",
              {
                autoPlay: true,
                loop: true,
                muted: true,
                className: "absolute inset-0 w-full h-full object-cover rounded-lg -z-10",
                style: { pointerEvents: "none" },
                children: /* @__PURE__ */ jsxRuntime2.jsx("source", { src: choiceButtonUrl })
              }
            ),
            /* @__PURE__ */ jsxRuntime2.jsx("span", { className: "relative z-10", children: interpolatedText })
          ]
        },
        index
      );
    }) });
  };
  const TextInputForm = ({ textInput, onSubmit, variables, project }) => {
    const [inputValue, setInputValue] = React2.useState("");
    const handleSubmit = (e) => {
      e.preventDefault();
      onSubmit(inputValue);
    };
    const interpolatedPrompt = interpolateVariables(textInput.prompt, variables, project);
    return /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0 bg-black/30 z-30 flex flex-col items-center justify-center p-8", children: /* @__PURE__ */ jsxRuntime2.jsxs("div", { className: "bg-black/70 rounded-lg border-2 border-slate-500 p-6 max-w-md w-full", children: [
      /* @__PURE__ */ jsxRuntime2.jsx("p", { className: "text-white mb-4 text-center", children: interpolatedPrompt }),
      /* @__PURE__ */ jsxRuntime2.jsxs("form", { onSubmit: handleSubmit, children: [
        /* @__PURE__ */ jsxRuntime2.jsx(
          "input",
          {
            type: "text",
            value: inputValue,
            onChange: (e) => setInputValue(e.target.value),
            placeholder: textInput.placeholder,
            maxLength: textInput.maxLength,
            className: "w-full px-3 py-2 bg-slate-800 text-white border border-slate-600 rounded focus:outline-none focus:border-slate-400",
            autoFocus: true
          }
        ),
        /* @__PURE__ */ jsxRuntime2.jsx(
          "button",
          {
            type: "submit",
            className: "w-full mt-4 px-4 py-2 bg-slate-700 hover:bg-slate-600 text-white rounded transition-colors",
            children: "Submit"
          }
        )
      ] })
    ] }) });
  };
  const ButtonElement = ({ element, style, playSound, onAction, getElementAssetUrl, variables = {}, project }) => {
    const [isHovered, setIsHovered] = React2.useState(false);
    const bgUrl = getElementAssetUrl(element.image);
    const hoverUrl = getElementAssetUrl(element.hoverImage);
    const displayUrl = isHovered && hoverUrl ? hoverUrl : bgUrl;
    const textStyle = fontSettingsToStyle(element.font);
    const interpolatedText = project ? interpolateVariables(element.text, variables, project) : element.text;
    const handleClick = () => {
      try {
        playSound(element.clickSoundId);
      } catch (e) {
      }
      if (element.action) {
        onAction(element.action);
      }
      if (element.actions && element.actions.length > 0) {
        element.actions.forEach((action) => onAction(action));
      }
    };
    return /* @__PURE__ */ jsxRuntime2.jsxs(
      "button",
      {
        style: { ...style, fontFamily: "inherit", fontSize: "inherit", lineHeight: "inherit" },
        className: "transition-transform transform hover:scale-105 relative flex items-center justify-center",
        onMouseEnter: () => {
          try {
            playSound(element.hoverSoundId);
          } catch (e) {
          }
          setIsHovered(true);
        },
        onMouseLeave: () => setIsHovered(false),
        onClick: handleClick,
        children: [
          displayUrl ? /* @__PURE__ */ jsxRuntime2.jsx("img", { src: displayUrl, alt: element.text, className: "absolute inset-0 w-full h-full object-fill" }) : /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0 w-full h-full bg-slate-700/80" }),
          /* @__PURE__ */ jsxRuntime2.jsx("span", { className: "relative z-10", style: { ...textStyle, display: "inline-block", pointerEvents: "none" }, children: interpolatedText })
        ]
      },
      element.id
    );
  };
  const UIScreenRenderer = React2.memo(({ screenId, onAction, settings, onSettingsChange, assetResolver, gameSaves, playSound, variables = {}, onVariableChange }) => {
    const { project } = useProject();
    const screen = project.uiScreens[screenId];
    if (!screen) return /* @__PURE__ */ jsxRuntime2.jsxs("div", { className: "text-red-500", children: [
      "Error: Screen ",
      screenId,
      " not found."
    ] });
    const getBackgroundElement = () => {
      if (screen.background.type === "color") {
        return /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0", style: { backgroundColor: screen.background.value } });
      }
      if (screen.background.assetId) {
        const url = assetResolver(screen.background.assetId, screen.background.type);
        if (url) {
          if (screen.background.type === "image") {
            return /* @__PURE__ */ jsxRuntime2.jsx("img", { src: url, alt: "", className: "absolute inset-0 w-full h-full object-cover" });
          }
          if (screen.background.type === "video") {
            return /* @__PURE__ */ jsxRuntime2.jsx("video", { src: url, autoPlay: true, loop: true, muted: true, className: "absolute inset-0 w-full h-full object-cover" });
          }
        }
      }
      return null;
    };
    const renderElement = (element, variables2, project2) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
      const style = {
        position: "absolute",
        left: \`\${element.x}%\`,
        top: \`\${element.y}%\`,
        width: \`\${element.width}%\`,
        height: \`\${element.height}%\`,
        transform: \`translate(-\${element.anchorX * 100}%, -\${element.anchorY * 100}%)\`,
        overflow: "hidden"
        // Prevent content overflow when using cover
      };
      const getElementAssetUrl = (image) => {
        if (!image) return null;
        return assetResolver(image.id, image.type);
      };
      switch (element.type) {
        case UIElementType.Button: {
          const el = element;
          return /* @__PURE__ */ jsxRuntime2.jsx(ButtonElement, { element: el, style, playSound, onAction, getElementAssetUrl, variables: variables2, project: project2 }, el.id);
        }
        case UIElementType.Text: {
          const el = element;
          const hAlignClass = { left: "justify-start", center: "justify-center", right: "justify-end" }[el.textAlign || "center"];
          const vAlignClass = { top: "items-start", middle: "items-center", bottom: "items-end" }[el.verticalAlign || "middle"];
          const interpolatedText = interpolateVariables(el.text, variables2, project2);
          return /* @__PURE__ */ jsxRuntime2.jsx(
            "div",
            {
              style,
              className: \`flex \${hAlignClass} \${vAlignClass} p-1\`,
              children: /* @__PURE__ */ jsxRuntime2.jsx("div", { style: fontSettingsToStyle(el.font), children: interpolatedText })
            },
            el.id
          );
        }
        case UIElementType.Image: {
          const el = element;
          const url = getElementAssetUrl(el.image);
          if (!url) return /* @__PURE__ */ jsxRuntime2.jsx("div", { style, className: "bg-slate-800/50" }, el.id);
          const isVideo = ((_a = el.image) == null ? void 0 : _a.type) === "video";
          const containerStyle = {
            ...style,
            overflow: "hidden"
          };
          const mediaStyle = {
            width: "100%",
            height: "100%",
            objectFit: el.objectFit || "contain",
            display: "block"
          };
          if (isVideo) {
            console.log("[Video Element] Name:", el.name);
            console.log("  Object Fit:", el.objectFit);
            console.log("  Element Size:", \`\${element.width}% x \${element.height}%\`);
            console.log("  Container Style:", {
              position: containerStyle.position,
              left: containerStyle.left,
              top: containerStyle.top,
              width: containerStyle.width,
              height: containerStyle.height,
              overflow: containerStyle.overflow
            });
            console.log("  Media Style:", mediaStyle);
            return /* @__PURE__ */ jsxRuntime2.jsx("div", { style: containerStyle, children: /* @__PURE__ */ jsxRuntime2.jsxs(
              "video",
              {
                src: url,
                style: mediaStyle,
                autoPlay: true,
                loop: true,
                muted: true,
                playsInline: true,
                onLoadedData: () => console.log("[Video Loaded]", el.name),
                onError: (e) => {
                  var _a2, _b2;
                  console.error("[Video Error]", el.name);
                  const video = e.currentTarget;
                  console.error("  Error Code:", (_a2 = video.error) == null ? void 0 : _a2.code);
                  console.error("  Error Message:", (_b2 = video.error) == null ? void 0 : _b2.message);
                  console.error("  Network State:", video.networkState, "(1=LOADING, 2=IDLE, 3=NO_SOURCE)");
                  console.error("  Ready State:", video.readyState);
                  console.error("  Video src:", video.src);
                },
                children: [
                  /* @__PURE__ */ jsxRuntime2.jsx("source", { src: url, type: "video/webm" }),
                  /* @__PURE__ */ jsxRuntime2.jsx("source", { src: url, type: "video/mp4" }),
                  "Your browser doesn't support this video format."
                ]
              }
            ) }, el.id);
          } else {
            console.log("[Image Element] Name:", el.name);
            console.log("  Object Fit:", el.objectFit);
            console.log("  Element Size:", \`\${element.width}% x \${element.height}%\`);
            console.log("  Container Style:", {
              position: containerStyle.position,
              left: containerStyle.left,
              top: containerStyle.top,
              width: containerStyle.width,
              height: containerStyle.height,
              overflow: containerStyle.overflow
            });
            console.log("  Media Style:", mediaStyle);
            return /* @__PURE__ */ jsxRuntime2.jsx("div", { style: containerStyle, children: /* @__PURE__ */ jsxRuntime2.jsx(
              "img",
              {
                src: url,
                alt: el.name,
                style: mediaStyle,
                onError: (e) => console.error("[Image Error]", el.name, ":", e)
              }
            ) }, el.id);
          }
        }
        case UIElementType.SettingsSlider: {
          const el = element;
          let value;
          let min;
          let max;
          let step;
          if (el.variableId) {
            value = Number(variables2[el.variableId]) || (el.minValue ?? 0);
            min = el.minValue ?? 0;
            max = el.maxValue ?? 100;
            step = 1;
          } else {
            const settingKey = el.setting === "textSpeed" ? "textSpeed" : el.setting;
            value = settings[settingKey];
            min = el.setting === "textSpeed" ? 10 : 0;
            max = el.setting === "textSpeed" ? 100 : 1;
            step = el.setting === "textSpeed" ? 1 : 0.01;
          }
          const thumbUrl = el.thumbImage ? getElementAssetUrl(el.thumbImage) : null;
          const trackUrl = el.trackImage ? getElementAssetUrl(el.trackImage) : null;
          const customSliderStyle = {
            // Custom thumb via CSS variable (if no image)
            ...el.thumbColor && !thumbUrl ? {
              ["--slider-thumb-color"]: el.thumbColor
            } : {},
            // Custom track via CSS variable (if no image)
            ...el.trackColor && !trackUrl ? {
              ["--slider-track-color"]: el.trackColor
            } : {},
            // Thumb image as background
            ...thumbUrl ? {
              ["--slider-thumb-bg"]: \`url(\${thumbUrl})\`
            } : {},
            // Track image as background
            ...trackUrl ? {
              ["--slider-track-bg"]: \`url(\${trackUrl})\`
            } : {}
          };
          return /* @__PURE__ */ jsxRuntime2.jsx("div", { style, className: "flex items-center", children: /* @__PURE__ */ jsxRuntime2.jsx(
            "input",
            {
              type: "range",
              min,
              max,
              step,
              value,
              onChange: (e) => {
                const newValue = parseFloat(e.target.value);
                if (el.variableId) {
                  onVariableChange == null ? void 0 : onVariableChange(el.variableId, newValue);
                } else {
                  onSettingsChange(el.setting, newValue);
                }
                if (el.actions && el.actions.length > 0) {
                  el.actions.forEach((action) => onAction(action));
                }
              },
              style: customSliderStyle,
              className: thumbUrl || trackUrl ? "custom-slider" : ""
            }
          ) }, el.id);
        }
        case UIElementType.SettingsToggle: {
          const el = element;
          let isChecked;
          if (el.variableId) {
            const currentValue = variables2[el.variableId];
            if (el.checkedValue !== void 0 && el.uncheckedValue !== void 0) {
              isChecked = currentValue === el.checkedValue;
            } else {
              isChecked = Boolean(currentValue);
            }
          } else {
            isChecked = settings[el.setting];
          }
          const checkboxImage = isChecked ? el.checkedImage : el.uncheckedImage;
          const imageUrl = checkboxImage ? getElementAssetUrl(checkboxImage) : null;
          const handleToggle = () => {
            if (el.variableId) {
              if (el.checkedValue !== void 0 && el.uncheckedValue !== void 0) {
                const newValue = isChecked ? el.uncheckedValue : el.checkedValue;
                onVariableChange == null ? void 0 : onVariableChange(el.variableId, newValue);
              } else {
                onVariableChange == null ? void 0 : onVariableChange(el.variableId, !isChecked);
              }
            } else {
              onSettingsChange(el.setting, !isChecked);
            }
            if (el.actions && el.actions.length > 0) {
              el.actions.forEach((action) => onAction(action));
            }
          };
          return /* @__PURE__ */ jsxRuntime2.jsxs("div", { style, className: "flex items-center gap-2", children: [
            imageUrl ? /* @__PURE__ */ jsxRuntime2.jsx(
              "img",
              {
                src: imageUrl,
                alt: isChecked ? "checked" : "unchecked",
                onClick: handleToggle,
                className: "h-5 w-5 cursor-pointer object-contain"
              }
            ) : /* @__PURE__ */ jsxRuntime2.jsx(
              "input",
              {
                type: "checkbox",
                checked: isChecked,
                onChange: handleToggle,
                className: "h-5 w-5",
                style: el.checkboxColor ? { accentColor: el.checkboxColor } : {}
              }
            ),
            /* @__PURE__ */ jsxRuntime2.jsx("label", { style: fontSettingsToStyle(el.font), children: el.text })
          ] }, el.id);
        }
        case UIElementType.SaveSlotGrid: {
          const el = element;
          const isSaveMode = screenId === project2.ui.saveScreenId;
          return /* @__PURE__ */ jsxRuntime2.jsx("div", { style, className: "grid grid-cols-2 gap-4 overflow-y-auto p-2", children: Array.from({ length: el.slotCount }).map((_, i) => {
            const slotData = gameSaves[i + 1];
            const action = isSaveMode ? { type: UIActionType.SaveGame, slotNumber: i + 1 } : { type: UIActionType.LoadGame, slotNumber: i + 1 };
            return /* @__PURE__ */ jsxRuntime2.jsxs(
              "button",
              {
                onClick: () => {
                  if (!isSaveMode && !slotData) return;
                  onAction(action);
                },
                disabled: !isSaveMode && !slotData,
                className: "aspect-video bg-slate-800/80 p-3 rounded-lg border-2 border-slate-600 hover:border-sky-400 disabled:opacity-50 disabled:hover:border-slate-600 flex flex-col justify-between text-left",
                style: fontSettingsToStyle(el.font),
                children: [
                  /* @__PURE__ */ jsxRuntime2.jsxs("p", { className: "font-bold text-sky-300", children: [
                    "Slot ",
                    i + 1
                  ] }),
                  slotData ? /* @__PURE__ */ jsxRuntime2.jsxs("div", { className: "text-sm", children: [
                    /* @__PURE__ */ jsxRuntime2.jsx("p", { className: "truncate", children: slotData.sceneName }),
                    /* @__PURE__ */ jsxRuntime2.jsx("p", { className: "text-slate-400", children: new Date(slotData.timestamp).toLocaleString() })
                  ] }) : /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "flex-grow flex items-center justify-center text-slate-500", children: el.emptySlotText })
                ]
              },
              i
            );
          }) }, el.id);
        }
        case UIElementType.CharacterPreview: {
          const el = element;
          const character = project2.characters[el.characterId];
          if (!character) return null;
          const imageUrls = [];
          const videoUrls = [];
          let hasVideo = false;
          let videoLoop = false;
          if (character.baseVideoUrl) {
            videoUrls.push(character.baseVideoUrl);
            hasVideo = true;
            videoLoop = !!character.baseVideoLoop;
          } else if (character.baseImageUrl) {
            imageUrls.push(character.baseImageUrl);
          }
          const defaultExpression = el.expressionId ? character.expressions[el.expressionId] : null;
          Object.values(character.layers).forEach((layer) => {
            const variableId = el.layerVariableMap[layer.id];
            let asset = null;
            if (variableId && variables2) {
              const index = Number(variables2[variableId]) || 0;
              const assetArray = Object.values(layer.assets);
              asset = assetArray[index];
            } else if (defaultExpression && defaultExpression.layerConfiguration[layer.id]) {
              const assetId = defaultExpression.layerConfiguration[layer.id];
              asset = assetId ? layer.assets[assetId] : null;
            }
            if (asset) {
              if (asset.videoUrl) {
                videoUrls.push(asset.videoUrl);
                hasVideo = true;
                videoLoop = videoLoop || !!asset.loop;
              } else if (asset.imageUrl) {
                imageUrls.push(asset.imageUrl);
              }
            }
          });
          const containerStyle = {
            ...style,
            overflow: "hidden"
          };
          return /* @__PURE__ */ jsxRuntime2.jsx("div", { style: containerStyle, children: /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "relative w-full h-full", children: hasVideo && videoUrls.length > 0 ? videoUrls.map((url, index) => /* @__PURE__ */ jsxRuntime2.jsx(
            "video",
            {
              src: url,
              autoPlay: true,
              muted: true,
              loop: videoLoop,
              playsInline: true,
              className: "absolute top-0 left-0 w-full h-full object-contain",
              style: { zIndex: index }
            },
            index
          )) : imageUrls.map((url, index) => /* @__PURE__ */ jsxRuntime2.jsx(
            "img",
            {
              src: url,
              alt: "",
              className: "absolute top-0 left-0 w-full h-full object-contain",
              style: { zIndex: index }
            },
            index
          )) }) }, el.id);
        }
        case UIElementType.TextInput: {
          const el = element;
          const currentValue = String(variables2[el.variableId] || "");
          return /* @__PURE__ */ jsxRuntime2.jsx(
            "div",
            {
              style,
              children: /* @__PURE__ */ jsxRuntime2.jsx(
                "input",
                {
                  type: "text",
                  value: currentValue,
                  onChange: (e) => {
                    onVariableChange == null ? void 0 : onVariableChange(el.variableId, e.target.value);
                  },
                  placeholder: el.placeholder,
                  maxLength: el.maxLength,
                  className: "w-full h-full outline-none",
                  style: {
                    backgroundColor: el.backgroundColor || "#1e293b",
                    color: ((_b = el.font) == null ? void 0 : _b.color) || "#f1f5f9",
                    fontSize: \`\${((_c = el.font) == null ? void 0 : _c.size) || 16}px\`,
                    fontFamily: ((_d = el.font) == null ? void 0 : _d.family) || "Inter, system-ui, sans-serif",
                    fontWeight: ((_e = el.font) == null ? void 0 : _e.weight) || "normal",
                    fontStyle: ((_f = el.font) == null ? void 0 : _f.italic) ? "italic" : "normal",
                    border: \`2px solid \${el.borderColor || "#475569"}\`,
                    borderRadius: "4px",
                    padding: "8px 12px"
                  }
                }
              )
            },
            el.id
          );
        }
        case UIElementType.Dropdown: {
          const el = element;
          const currentValue = variables2[el.variableId];
          return /* @__PURE__ */ jsxRuntime2.jsx(
            "div",
            {
              style,
              children: /* @__PURE__ */ jsxRuntime2.jsx(
                "select",
                {
                  value: String(currentValue ?? ((_g = el.options[0]) == null ? void 0 : _g.value) ?? ""),
                  onChange: (e) => {
                    const selectedOption = el.options.find((opt) => String(opt.value) === e.target.value);
                    if (selectedOption) {
                      onVariableChange == null ? void 0 : onVariableChange(el.variableId, selectedOption.value);
                      if (el.actions && el.actions.length > 0) {
                        el.actions.forEach((action) => onAction(action));
                      }
                    }
                  },
                  className: "w-full h-full outline-none cursor-pointer",
                  style: {
                    backgroundColor: el.backgroundColor || "#1e293b",
                    color: ((_h = el.font) == null ? void 0 : _h.color) || "#f1f5f9",
                    fontSize: \`\${((_i = el.font) == null ? void 0 : _i.size) || 16}px\`,
                    fontFamily: ((_j = el.font) == null ? void 0 : _j.family) || "Inter, system-ui, sans-serif",
                    fontWeight: ((_k = el.font) == null ? void 0 : _k.weight) || "normal",
                    fontStyle: ((_l = el.font) == null ? void 0 : _l.italic) ? "italic" : "normal",
                    border: \`2px solid \${el.borderColor || "#475569"}\`,
                    borderRadius: "4px",
                    padding: "8px 12px"
                  },
                  onMouseEnter: (e) => {
                    if (el.hoverColor) {
                      e.currentTarget.style.backgroundColor = el.hoverColor;
                    }
                  },
                  onMouseLeave: (e) => {
                    e.currentTarget.style.backgroundColor = el.backgroundColor || "#1e293b";
                  },
                  children: el.options.map((opt) => /* @__PURE__ */ jsxRuntime2.jsx("option", { value: String(opt.value), children: opt.label }, opt.id))
                }
              )
            },
            el.id
          );
        }
        case UIElementType.Checkbox: {
          const el = element;
          const currentValue = variables2[el.variableId];
          const isChecked = currentValue === el.checkedValue;
          return /* @__PURE__ */ jsxRuntime2.jsxs(
            "div",
            {
              style,
              className: "flex items-center gap-2 cursor-pointer",
              onClick: () => {
                const newValue = isChecked ? el.uncheckedValue : el.checkedValue;
                onVariableChange == null ? void 0 : onVariableChange(el.variableId, newValue);
                if (el.actions && el.actions.length > 0) {
                  el.actions.forEach((action) => onAction(action));
                }
              },
              children: [
                /* @__PURE__ */ jsxRuntime2.jsx(
                  "input",
                  {
                    type: "checkbox",
                    checked: isChecked,
                    onChange: () => {
                    },
                    className: "w-5 h-5 cursor-pointer",
                    style: {
                      accentColor: el.checkboxColor || "#3b82f6"
                    }
                  }
                ),
                /* @__PURE__ */ jsxRuntime2.jsx(
                  "span",
                  {
                    style: {
                      color: el.labelColor || "#f1f5f9",
                      fontSize: \`\${((_m = el.font) == null ? void 0 : _m.size) || 16}px\`,
                      fontFamily: ((_n = el.font) == null ? void 0 : _n.family) || "Inter, system-ui, sans-serif",
                      fontWeight: ((_o = el.font) == null ? void 0 : _o.weight) || "normal",
                      fontStyle: ((_p = el.font) == null ? void 0 : _p.italic) ? "italic" : "normal",
                      cursor: "pointer",
                      userSelect: "none"
                    },
                    children: el.label
                  }
                )
              ]
            },
            el.id
          );
        }
        default:
          return null;
      }
    };
    return /* @__PURE__ */ jsxRuntime2.jsxs("div", { className: "absolute inset-0 w-full h-full", children: [
      getBackgroundElement(),
      Object.values(screen.elements).map((element) => renderElement(element, variables, project))
    ] });
  });
  const LivePreview = ({ onClose, hideCloseButton = false, autoStartMusic = false }) => {
    const { project } = useProject();
    const getValidTitleScreenId = React2.useCallback(() => {
      if (project.ui.titleScreenId && project.uiScreens[project.ui.titleScreenId]) {
        return project.ui.titleScreenId;
      }
      const fallbackByName = Object.values(project.uiScreens).find((s) => s.name.toLowerCase() === "title screen");
      if (fallbackByName) {
        return fallbackByName.id;
      }
      return Object.keys(project.uiScreens)[0] || null;
    }, [project.ui.titleScreenId, project.uiScreens]);
    const titleScreenId = getValidTitleScreenId();
    const [screenStack, setScreenStack] = React2.useState(titleScreenId ? [titleScreenId] : []);
    const [hudStack, setHudStack] = React2.useState([]);
    const [settings, setSettings] = React2.useState(defaultSettings);
    const [playerState, setPlayerState] = React2.useState(null);
    const [gameSaves, setGameSaves] = React2.useState({});
    const [isJustLoaded, setIsJustLoaded] = React2.useState(false);
    const [menuVariables, setMenuVariables] = React2.useState(() => {
      const initVars = {};
      Object.values(project.variables).forEach((v) => {
        initVars[v.id] = v.defaultValue;
      });
      return initVars;
    });
    React2.useEffect(() => {
      const updatedVars = {};
      Object.values(project.variables).forEach((v) => {
        updatedVars[v.id] = menuVariables[v.id] !== void 0 ? menuVariables[v.id] : v.defaultValue;
      });
      setMenuVariables(updatedVars);
    }, [project.variables]);
    const musicAudioRef = React2.useRef(new Audio());
    const ambientNoiseAudioRef = React2.useRef(new Audio());
    const menuMusicUrlRef = React2.useRef(null);
    const menuAmbientUrlRef = React2.useRef(null);
    const audioFadeInterval = React2.useRef(null);
    const ambientFadeInterval = React2.useRef(null);
    const stageRef = React2.useRef(null);
    const stageSize = useStageSize(stageRef);
    const audioCtxRef = React2.useRef(null);
    const sfxBufferCacheRef = React2.useRef(/* @__PURE__ */ new Map());
    const sfxSourceNodesRef = React2.useRef([]);
    const sfxMasterGainRef = React2.useRef(null);
    React2.useRef(null);
    React2.useRef(/* @__PURE__ */ new Map());
    const MAX_SIMULTANEOUS_SFX = 8;
    const savesPersistentRef = React2.useRef(true);
    const inMemorySavesRef = React2.useRef({});
    const queuedMusicRef = React2.useRef(null);
    const userGestureDetectedRef = React2.useRef(false);
    const sfxPoolRef = React2.useRef([]);
    const lastProcessedCommandRef = React2.useRef(null);
    const assetResolver = React2.useCallback((assetId, type) => {
      var _a, _b;
      console.log("[AssetResolver] Called with assetId:", assetId, "type:", type);
      if (!assetId) {
        console.log("[AssetResolver] No assetId provided, returning null");
        return null;
      }
      let resolvedUrl = null;
      switch (type) {
        case "audio":
          resolvedUrl = ((_a = project.audio[assetId]) == null ? void 0 : _a.audioUrl) || null;
          console.log("[AssetResolver] Audio asset lookup:", assetId, "", resolvedUrl);
          return resolvedUrl;
        case "video":
          resolvedUrl = ((_b = project.videos[assetId]) == null ? void 0 : _b.videoUrl) || null;
          console.log("[AssetResolver] Video asset lookup:", assetId, "", resolvedUrl);
          return resolvedUrl;
        case "image": {
          if (project.backgrounds[assetId]) {
            const bg = project.backgrounds[assetId];
            resolvedUrl = bg.videoUrl || bg.imageUrl || null;
            console.log("[AssetResolver] Background asset lookup:", assetId, "", resolvedUrl);
            return resolvedUrl;
          }
          if (project.images && project.images[assetId]) {
            const img = project.images[assetId];
            resolvedUrl = img.videoUrl || img.imageUrl || null;
            console.log("[AssetResolver] Image asset lookup:", assetId, "", resolvedUrl);
            return resolvedUrl;
          }
          for (const charId in project.characters) {
            const char = project.characters[charId];
            if (char.id === assetId) {
              resolvedUrl = char.baseVideoUrl || char.baseImageUrl || null;
              console.log("[AssetResolver] Character base asset lookup:", assetId, "", resolvedUrl);
              return resolvedUrl;
            }
            for (const layerId in char.layers) {
              const layer = char.layers[layerId];
              if (layer.assets[assetId]) {
                const asset = layer.assets[assetId];
                resolvedUrl = asset.videoUrl || asset.imageUrl || null;
                console.log("[AssetResolver] Character layer asset lookup:", assetId, "", resolvedUrl);
                return resolvedUrl;
              }
            }
          }
          console.log("[AssetResolver] Image asset not found for:", assetId);
          return null;
        }
      }
    }, [project]);
    const getAssetMetadata = React2.useCallback((assetId, type) => {
      if (!assetId) return { isVideo: false, loop: false };
      if (project.backgrounds[assetId]) {
        const bg = project.backgrounds[assetId];
        return { isVideo: !!bg.isVideo, loop: !!bg.loop };
      }
      if (project.images && project.images[assetId]) {
        const img = project.images[assetId];
        return { isVideo: !!img.isVideo, loop: !!img.loop };
      }
      for (const charId in project.characters) {
        const char = project.characters[charId];
        if (char.id === assetId) {
          return { isVideo: !!char.isBaseVideo, loop: !!char.baseVideoLoop };
        }
        for (const layerId in char.layers) {
          const layer = char.layers[layerId];
          if (layer.assets[assetId]) {
            const asset = layer.assets[assetId];
            return { isVideo: !!asset.isVideo, loop: !!asset.loop };
          }
        }
      }
      return { isVideo: false, loop: false };
    }, [project]);
    const fadeAudio = React2.useCallback((audioElement, targetVolume, duration, onComplete) => {
      const intervalRef = audioElement === musicAudioRef.current ? audioFadeInterval : ambientFadeInterval;
      if (intervalRef.current) clearInterval(intervalRef.current);
      const startVolume = audioElement.volume;
      const volumeChange = targetVolume - startVolume;
      if (duration === 0) {
        audioElement.volume = targetVolume;
        onComplete == null ? void 0 : onComplete();
        return;
      }
      const startTime = Date.now();
      intervalRef.current = window.setInterval(() => {
        const elapsedTime = Date.now() - startTime;
        const progress = Math.min(elapsedTime / (duration * 1e3), 1);
        audioElement.volume = startVolume + volumeChange * progress;
        if (progress >= 1) {
          if (intervalRef.current) clearInterval(intervalRef.current);
          intervalRef.current = null;
          onComplete == null ? void 0 : onComplete();
        }
      }, 30);
    }, []);
    const stopAndResetMusic = React2.useCallback(() => {
      const audio = musicAudioRef.current;
      if (audio && !audio.paused) {
        fadeAudio(audio, 0, 0.5, () => {
          audio.pause();
          audio.src = "";
        });
      } else if (audio) {
        audio.src = "";
      }
      menuMusicUrlRef.current = null;
      const ambientAudio = ambientNoiseAudioRef.current;
      if (ambientAudio && !ambientAudio.paused) {
        fadeAudio(ambientAudio, 0, 0.5, () => {
          ambientAudio.pause();
          ambientAudio.src = "";
        });
      } else if (ambientAudio) {
        ambientAudio.src = "";
      }
      menuAmbientUrlRef.current = null;
    }, [fadeAudio]);
    const getGameSaves = React2.useCallback(() => {
      try {
        const savesJson = localStorage.getItem(\`vn-saves-\${project.id}\`);
        return savesJson ? JSON.parse(savesJson) : {};
      } catch (e) {
        console.warn("Failed to load saves from localStorage:", e);
        return {};
      }
    }, [project.id]);
    const saveGameSaves = React2.useCallback((saves) => {
      try {
        localStorage.setItem(\`vn-saves-\${project.id}\`, JSON.stringify(saves));
        savesPersistentRef.current = true;
      } catch (e) {
        console.error("Failed to save to localStorage:", e);
        savesPersistentRef.current = false;
        inMemorySavesRef.current = saves;
      }
    }, [project.id]);
    React2.useCallback(() => {
      const saves = savesPersistentRef.current ? getGameSaves() : inMemorySavesRef.current;
      const blob = new Blob([JSON.stringify(saves, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = \`vn-saves-\${project.id}.json\`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }, [getGameSaves, project.id]);
    React2.useEffect(() => {
      setGameSaves(getGameSaves());
    }, [getGameSaves, screenStack]);
    const saveGame = (slotNumber) => {
      var _a;
      if (!playerState) return;
      const musicCurrentTime = musicAudioRef.current ? musicAudioRef.current.currentTime : 0;
      const finalMusicState = {
        ...playerState.musicState,
        currentTime: musicCurrentTime,
        isPlaying: !musicAudioRef.current.paused
      };
      const saves = getGameSaves();
      saves[slotNumber] = {
        timestamp: Date.now(),
        sceneName: ((_a = project.scenes[playerState.currentSceneId]) == null ? void 0 : _a.name) || "Unknown Scene",
        playerStateData: {
          currentSceneId: playerState.currentSceneId,
          currentCommands: playerState.currentCommands,
          currentIndex: playerState.currentIndex,
          commandStack: playerState.commandStack,
          variables: playerState.variables,
          stageState: playerState.stageState,
          musicState: finalMusicState
        }
      };
      if (!savesPersistentRef.current) {
        inMemorySavesRef.current = saves;
      } else {
        saveGameSaves(saves);
      }
      setGameSaves(saves);
    };
    const loadGame = (slotNumber) => {
      var _a;
      stopAndResetMusic();
      const saves = savesPersistentRef.current ? getGameSaves() : inMemorySavesRef.current;
      const saveData = saves[slotNumber];
      if (saveData) {
        setPlayerState({
          mode: "playing",
          currentSceneId: saveData.playerStateData.currentSceneId,
          currentCommands: saveData.playerStateData.currentCommands || ((_a = project.scenes[saveData.playerStateData.currentSceneId]) == null ? void 0 : _a.commands) || [],
          currentIndex: saveData.playerStateData.currentIndex ?? 0,
          commandStack: saveData.playerStateData.commandStack || [],
          variables: saveData.playerStateData.variables,
          stageState: saveData.playerStateData.stageState,
          uiState: { dialogue: null, choices: null, textInput: null, movieUrl: null, isWaitingForInput: false, isTransitioning: false, transitionElement: null, flash: null },
          musicState: saveData.playerStateData.musicState
        });
        setScreenStack([]);
        setHudStack([]);
        setIsJustLoaded(true);
      }
    };
    const startNewGame = React2.useCallback(() => {
      var _a;
      stopAndResetMusic();
      const initialVariables = { ...menuVariables };
      let startSceneId = project.startSceneId;
      const startScene = project.scenes[startSceneId];
      if (startScene && startScene.conditions && startScene.conditions.length > 0) {
        const conditionsMet = startScene.conditions.every((condition) => {
          const varValue = initialVariables[condition.variableId];
          if (varValue === void 0) return false;
          switch (condition.operator) {
            case "is true":
              return !!varValue;
            case "is false":
              return !varValue;
            case "==":
              return String(varValue).toLowerCase() == String(condition.value).toLowerCase();
            case "!=":
              return String(varValue).toLowerCase() != String(condition.value).toLowerCase();
            case ">":
              return Number(varValue) > Number(condition.value);
            case "<":
              return Number(varValue) < Number(condition.value);
            case ">=":
              return Number(varValue) >= Number(condition.value);
            case "<=":
              return Number(varValue) <= Number(condition.value);
            case "contains":
              return String(varValue).toLowerCase().includes(String(condition.value).toLowerCase());
            case "startsWith":
              return String(varValue).toLowerCase().startsWith(String(condition.value).toLowerCase());
            default:
              return false;
          }
        });
        if (!conditionsMet && startScene.fallbackSceneId) {
          console.log(\`Start scene "\${startScene.name}" conditions not met, using fallback\`);
          startSceneId = startScene.fallbackSceneId;
        }
      }
      setPlayerState({
        mode: "playing",
        currentSceneId: startSceneId,
        currentCommands: ((_a = project.scenes[startSceneId]) == null ? void 0 : _a.commands) || [],
        currentIndex: 0,
        commandStack: [],
        variables: initialVariables,
        stageState: { backgroundUrl: null, characters: {}, textOverlays: [], imageOverlays: [], buttonOverlays: [], screen: { shake: { active: false, intensity: 0 }, tint: "transparent", zoom: 1, panX: 0, panY: 0, transitionDuration: 0.5 } },
        uiState: { dialogue: null, choices: null, textInput: null, movieUrl: null, isWaitingForInput: false, isTransitioning: false, transitionElement: null, flash: null },
        musicState: { audioId: null, loop: false, currentTime: 0, isPlaying: false }
      });
      setScreenStack([]);
      setHudStack([]);
    }, [project, stopAndResetMusic, menuVariables]);
    const evaluateConditions = React2.useCallback((conditions, variables) => {
      if (!conditions || conditions.length === 0) {
        return true;
      }
      return conditions.every((condition) => {
        const varValue = variables[condition.variableId];
        const projectVar = project.variables[condition.variableId];
        const effectiveVarValue = varValue !== void 0 ? varValue : projectVar ? projectVar.defaultValue : void 0;
        if (effectiveVarValue === void 0) {
          return false;
        }
        switch (condition.operator) {
          case "is true":
            return !!effectiveVarValue;
          case "is false":
            return !effectiveVarValue;
          case "==":
            return String(effectiveVarValue).toLowerCase() == String(condition.value).toLowerCase();
          case "!=":
            return String(effectiveVarValue).toLowerCase() != String(condition.value).toLowerCase();
          case ">":
            return Number(effectiveVarValue) > Number(condition.value);
          case "<":
            return Number(effectiveVarValue) < Number(condition.value);
          case ">=":
            return Number(effectiveVarValue) >= Number(condition.value);
          case "<=":
            return Number(effectiveVarValue) <= Number(condition.value);
          case "contains":
            return String(effectiveVarValue).toLowerCase().includes(String(condition.value).toLowerCase());
          case "startsWith":
            return String(effectiveVarValue).toLowerCase().startsWith(String(condition.value).toLowerCase());
          default:
            return false;
        }
      });
    }, [project.variables]);
    const navigateToScene = React2.useCallback((targetSceneId, variables) => {
      let sceneToPlay = targetSceneId;
      let attempts = 0;
      const maxAttempts = 50;
      while (attempts < maxAttempts) {
        const scene = project.scenes[sceneToPlay];
        if (!scene) {
          console.error(\`Scene not found: \${sceneToPlay}\`);
          return targetSceneId;
        }
        if (evaluateConditions(scene.conditions, variables)) {
          return sceneToPlay;
        }
        if (scene.fallbackSceneId && project.scenes[scene.fallbackSceneId]) {
          console.log(\`Scene "\${scene.name}" conditions failed, jumping to fallback: \${scene.fallbackSceneId}\`);
          sceneToPlay = scene.fallbackSceneId;
        } else {
          const sceneIds = Object.keys(project.scenes);
          const currentIndex = sceneIds.indexOf(sceneToPlay);
          if (currentIndex !== -1 && currentIndex < sceneIds.length - 1) {
            sceneToPlay = sceneIds[currentIndex + 1];
            console.log(\`Scene "\${scene.name}" conditions failed, trying next scene: \${sceneToPlay}\`);
          } else {
            console.log(\`Scene "\${scene.name}" conditions failed and no fallback/next scene available\`);
            return sceneToPlay;
          }
        }
        attempts++;
      }
      console.error("Scene navigation exceeded max attempts - possible circular fallback");
      return targetSceneId;
    }, [project.scenes, evaluateConditions]);
    React2.useEffect(() => {
      if ((playerState == null ? void 0 : playerState.mode) === "playing") {
        return;
      }
      const audio = musicAudioRef.current;
      const activeScreen = screenStack.length > 0 ? project.uiScreens[screenStack[screenStack.length - 1]] : null;
      if (!activeScreen) {
        if (!audio.paused) {
          fadeAudio(audio, 0, 0.5, () => audio.pause());
        }
        menuMusicUrlRef.current = null;
        return;
      }
      const musicInfo = activeScreen.music;
      if ((playerState == null ? void 0 : playerState.mode) === "paused" && musicInfo.policy === "continue") {
        return;
      }
      const newAudioUrl = (musicInfo == null ? void 0 : musicInfo.audioId) ? assetResolver(musicInfo.audioId, "audio") : null;
      const normalize = (value) => {
        if (!value) return null;
        try {
          return new URL(value, window.location.href).href;
        } catch (e) {
          return value;
        }
      };
      const currentSrcNormalized = audio.src ? normalize(audio.src) : null;
      const newSrcNormalized = normalize(newAudioUrl);
      if (!newAudioUrl) {
        if (!audio.paused) {
          fadeAudio(audio, 0, 0.5, () => audio.pause());
        }
        menuMusicUrlRef.current = null;
        return;
      }
      const startPlayback = () => {
        audio.loop = true;
        audio.play().then(() => {
          menuMusicUrlRef.current = newAudioUrl;
          fadeAudio(audio, settings.musicVolume, 0.5);
        }).catch((e) => {
          console.error("Menu music play failed:", e);
          if (!userGestureDetectedRef.current) {
            queuedMusicRef.current = { url: newAudioUrl, loop: true, fadeDuration: 0.5 };
          }
        });
      };
      if (currentSrcNormalized !== newSrcNormalized) {
        audio.src = newAudioUrl;
        audio.load();
        startPlayback();
      } else if (audio.paused) {
        startPlayback();
      } else {
        menuMusicUrlRef.current = newAudioUrl;
      }
    }, [screenStack, playerState == null ? void 0 : playerState.mode, project.uiScreens, assetResolver, settings.musicVolume, fadeAudio]);
    React2.useEffect(() => {
      if (musicAudioRef.current) musicAudioRef.current.volume = settings.musicVolume;
    }, [settings.musicVolume]);
    React2.useEffect(() => {
      const isInActiveGameplay = (playerState == null ? void 0 : playerState.mode) === "playing" && screenStack.length === 0;
      if (isInActiveGameplay) {
        return;
      }
      const audio = ambientNoiseAudioRef.current;
      const activeScreen = screenStack.length > 0 ? project.uiScreens[screenStack[screenStack.length - 1]] : null;
      if (!activeScreen) {
        if (audio && !audio.paused) {
          fadeAudio(audio, 0, 0.5, () => audio.pause());
        }
        menuAmbientUrlRef.current = null;
        return;
      }
      const ambientInfo = activeScreen.ambientNoise;
      if ((playerState == null ? void 0 : playerState.mode) === "paused" && ambientInfo.policy === "stop") {
        if (audio && !audio.paused) {
          fadeAudio(audio, 0, 0.5, () => audio.pause());
        }
        return;
      }
      const newAudioUrl = (ambientInfo == null ? void 0 : ambientInfo.audioId) ? assetResolver(ambientInfo.audioId, "audio") : null;
      const normalize = (value) => {
        if (!value) return null;
        try {
          return new URL(value, window.location.href).href;
        } catch (e) {
          return value;
        }
      };
      const currentSrcNormalized = (audio == null ? void 0 : audio.src) ? normalize(audio.src) : null;
      const newSrcNormalized = normalize(newAudioUrl);
      if (!newAudioUrl) {
        if (audio && !audio.paused) {
          fadeAudio(audio, 0, 0.5, () => audio.pause());
        }
        menuAmbientUrlRef.current = null;
        return;
      }
      const startAmbientPlayback = () => {
        if (!audio) return;
        audio.loop = true;
        audio.volume = 0;
        audio.play().then(() => {
          menuAmbientUrlRef.current = newAudioUrl;
          fadeAudio(audio, settings.sfxVolume, 0.5);
        }).catch((e) => {
          console.error("[Ambient] Play failed:", e);
        });
      };
      if (currentSrcNormalized !== newSrcNormalized) {
        if (!audio) return;
        audio.src = newAudioUrl;
        audio.load();
        startAmbientPlayback();
      } else if (audio && audio.paused) {
        startAmbientPlayback();
      } else {
        menuAmbientUrlRef.current = newAudioUrl;
      }
    }, [screenStack, playerState == null ? void 0 : playerState.mode, project.uiScreens, assetResolver, settings.sfxVolume, fadeAudio]);
    React2.useEffect(() => {
      if (ambientNoiseAudioRef.current) ambientNoiseAudioRef.current.volume = settings.sfxVolume;
    }, [settings.sfxVolume]);
    React2.useEffect(() => {
      if ((playerState == null ? void 0 : playerState.mode) !== "playing" || screenStack.length > 0) {
        return;
      }
      const normalize = (value) => {
        if (!value) return null;
        try {
          return new URL(value, window.location.href).href;
        } catch (e) {
          return value;
        }
      };
      const musicAudio = musicAudioRef.current;
      if (menuMusicUrlRef.current) {
        const currentSrc = (musicAudio == null ? void 0 : musicAudio.src) ? normalize(musicAudio.src) : null;
        const menuSrc = normalize(menuMusicUrlRef.current);
        if (currentSrc && menuSrc && currentSrc === menuSrc && musicAudio && !musicAudio.paused) {
          fadeAudio(musicAudio, 0, 0.5, () => musicAudio.pause());
        }
        menuMusicUrlRef.current = null;
      }
      const ambientAudio = ambientNoiseAudioRef.current;
      if (menuAmbientUrlRef.current && ambientAudio && !ambientAudio.paused) {
        fadeAudio(ambientAudio, 0, 0.5, () => ambientAudio.pause());
        menuAmbientUrlRef.current = null;
      }
    }, [playerState == null ? void 0 : playerState.mode, screenStack, fadeAudio]);
    React2.useEffect(() => {
      const handler = () => {
        userGestureDetectedRef.current = true;
        const queued = queuedMusicRef.current;
        if (queued) {
          const audio = musicAudioRef.current;
          audio.src = queued.url;
          audio.loop = queued.loop;
          audio.load();
          audio.play().then(() => {
            fadeAudio(audio, settings.musicVolume, queued.fadeDuration);
            queuedMusicRef.current = null;
          }).catch((e) => console.error("Queued music play failed:", e));
        }
      };
      window.addEventListener("click", handler, { once: true });
      return () => window.removeEventListener("click", handler);
    }, [fadeAudio, settings.musicVolume]);
    React2.useEffect(() => {
      if (autoStartMusic) {
        userGestureDetectedRef.current = true;
      }
    }, [autoStartMusic]);
    React2.useEffect(() => {
      if (isJustLoaded && (playerState == null ? void 0 : playerState.mode) === "playing") {
        const { musicState } = playerState;
        if (musicState.audioId) {
          const audio = musicAudioRef.current;
          const url = assetResolver(musicState.audioId, "audio");
          if (url) {
            audio.src = url;
            audio.loop = musicState.loop;
            audio.currentTime = musicState.currentTime;
            audio.play().then(() => {
              fadeAudio(audio, settings.musicVolume, 0.5);
            }).catch((e) => console.error("Failed to resume music on load:", e));
          }
        }
        setIsJustLoaded(false);
      }
    }, [isJustLoaded, playerState, assetResolver, fadeAudio, settings.musicVolume]);
    const stopAllSfx = React2.useCallback(() => {
      try {
        sfxSourceNodesRef.current.forEach((src) => {
          try {
            src.stop();
          } catch (e) {
          }
        });
      } catch (e) {
      }
      sfxSourceNodesRef.current = [];
      sfxPoolRef.current.forEach((a) => {
        try {
          a.pause();
          a.currentTime = 0;
          a.src = "";
        } catch (e) {
        }
      });
      sfxPoolRef.current = [];
      sfxBufferCacheRef.current.clear();
    }, []);
    const playSound = React2.useCallback((soundId, volume) => {
      console.log("[SFX] playSound called with soundId:", soundId, "volume:", volume);
      if (!soundId) return;
      try {
        const url = assetResolver(soundId, "audio");
        console.log("[SFX] assetResolver returned URL:", url, "for soundId:", soundId);
        if (!url) {
          console.warn(\`[SFX] No audio URL found for soundId: \${soundId}\`);
          return;
        }
        console.log("[SFX] Creating HTMLAudio element for playback");
        const audio = new Audio(url);
        audio.volume = (typeof volume === "number" ? Math.max(0, Math.min(1, volume)) : 1) * settings.sfxVolume;
        if (sfxPoolRef.current.length >= MAX_SIMULTANEOUS_SFX) {
          const oldest = sfxPoolRef.current.shift();
          try {
            oldest == null ? void 0 : oldest.pause();
            oldest.currentTime = 0;
          } catch (e) {
          }
        }
        sfxPoolRef.current.push(audio);
        console.log("[SFX] Playing audio, volume:", audio.volume);
        audio.play().then(() => {
          console.log("[SFX] Audio playback started successfully");
        }).catch((e) => {
          console.error("[SFX] Audio playback failed:", e);
        });
        audio.addEventListener("ended", () => {
          console.log("[SFX] Audio playback ended");
          sfxPoolRef.current = sfxPoolRef.current.filter((a) => a !== audio);
        }, { once: true });
      } catch (outerError) {
        console.error("[SFX] Critical error in playSound:", outerError);
        console.error("[SFX] Error stack:", outerError instanceof Error ? outerError.stack : "N/A");
      }
    }, [assetResolver, settings.sfxVolume]);
    React2.useEffect(() => {
      var _a;
      if (sfxMasterGainRef.current) {
        try {
          sfxMasterGainRef.current.gain.setTargetAtTime(settings.sfxVolume, ((_a = audioCtxRef.current) == null ? void 0 : _a.currentTime) || 0, 0.01);
        } catch (e) {
        }
      }
    }, [settings.sfxVolume]);
    React2.useEffect(() => {
      var _a;
      if (!playerState || playerState.mode !== "playing") {
        lastProcessedCommandRef.current = null;
        return;
      }
      if (playerState.uiState.isWaitingForInput || playerState.uiState.isTransitioning || playerState.uiState.choices) {
        return;
      }
      if (hudStack.length > 0) {
        return;
      }
      const command = playerState.currentCommands[playerState.currentIndex];
      if (!command) {
        if (playerState.commandStack.length > 0) {
          const popped = playerState.commandStack[playerState.commandStack.length - 1];
          setPlayerState((p) => {
            if (!p) return null;
            const newStack = p.commandStack.slice(0, -1);
            return { ...p, currentSceneId: popped.sceneId, currentCommands: popped.commands, currentIndex: popped.index, commandStack: newStack };
          });
        } else {
          console.log("End of scene - trying to advance to next scene");
          const sceneIds = Object.keys(project.scenes);
          const currentSceneIndex = sceneIds.indexOf(playerState.currentSceneId);
          if (currentSceneIndex !== -1 && currentSceneIndex < sceneIds.length - 1) {
            const nextSceneId = navigateToScene(sceneIds[currentSceneIndex + 1], playerState.variables);
            const nextScene = project.scenes[nextSceneId];
            if (nextScene) {
              console.log(\`Advancing to next scene: \${nextSceneId}\`);
              setPlayerState((p) => p ? {
                ...p,
                currentSceneId: nextSceneId,
                currentCommands: nextScene.commands,
                currentIndex: 0
              } : null);
            } else {
              console.log("No valid next scene - returning to title");
              stopAndResetMusic();
              stopAllSfx();
              setPlayerState(null);
              if (project.ui.titleScreenId) {
                setScreenStack([project.ui.titleScreenId]);
              }
            }
          } else {
            console.log("Last scene completed - returning to title");
            stopAndResetMusic();
            stopAllSfx();
            setPlayerState(null);
            if (project.ui.titleScreenId) {
              setScreenStack([project.ui.titleScreenId]);
            }
          }
        }
        lastProcessedCommandRef.current = null;
        return;
      }
      const commandSignature = {
        sceneId: playerState.currentSceneId,
        index: playerState.currentIndex,
        commandId: command.id
      };
      const lastSignature = lastProcessedCommandRef.current;
      if (lastSignature && lastSignature.sceneId === commandSignature.sceneId && lastSignature.index === commandSignature.index && lastSignature.commandId === commandSignature.commandId) {
        return;
      }
      lastProcessedCommandRef.current = commandSignature;
      if (command.type === CommandType.BranchStart) {
        const branchCmd = command;
        const conditionsMet = evaluateConditions(branchCmd.conditions, playerState.variables);
        if (!conditionsMet) {
          const branchEndIndex = playerState.currentCommands.findIndex(
            (cmd, idx) => idx > playerState.currentIndex && cmd.type === CommandType.BranchEnd && cmd.branchId === branchCmd.branchId
          );
          if (branchEndIndex !== -1) {
            setPlayerState((p) => p ? { ...p, currentIndex: branchEndIndex + 1 } : null);
          } else {
            setPlayerState((p) => p ? { ...p, currentIndex: p.currentIndex + 1 } : null);
          }
          return;
        }
        setPlayerState((p) => p ? { ...p, currentIndex: p.currentIndex + 1 } : null);
        return;
      }
      if (!evaluateConditions(command.conditions, playerState.variables)) {
        setPlayerState((p) => p ? { ...p, currentIndex: p.currentIndex + 1 } : null);
        return;
      }
      const advance = () => {
        const nextIndex = playerState.currentIndex + 1;
        if (nextIndex >= playerState.currentCommands.length) {
          if (playerState.commandStack.length > 0) {
            const popped = playerState.commandStack[playerState.commandStack.length - 1];
            setPlayerState((p) => {
              if (!p) return null;
              const newStack = p.commandStack.slice(0, -1);
              return { ...p, currentSceneId: popped.sceneId, currentCommands: popped.commands, currentIndex: popped.index, commandStack: newStack };
            });
          } else {
            const sceneIds = Object.keys(project.scenes);
            const currentSceneIndex = sceneIds.indexOf(playerState.currentSceneId);
            if (currentSceneIndex !== -1 && currentSceneIndex < sceneIds.length - 1) {
              const nextSceneId = navigateToScene(sceneIds[currentSceneIndex + 1], playerState.variables);
              const nextScene = project.scenes[nextSceneId];
              if (nextScene) {
                setPlayerState((p) => p ? {
                  ...p,
                  currentSceneId: nextSceneId,
                  currentCommands: nextScene.commands,
                  currentIndex: 0
                } : null);
                return;
              }
            }
            stopAndResetMusic();
            stopAllSfx();
            setPlayerState(null);
            if (project.ui.titleScreenId) {
              setScreenStack([project.ui.titleScreenId]);
            }
          }
        } else {
          setPlayerState((p) => p ? { ...p, currentIndex: nextIndex } : null);
        }
      };
      const shouldRunAsync = ((_a = command.modifiers) == null ? void 0 : _a.runAsync) === true;
      let instantAdvance = true;
      (async () => {
        switch (command.type) {
          case CommandType.Group: {
            break;
          }
          case CommandType.BranchStart: {
            break;
          }
          case CommandType.BranchEnd: {
            break;
          }
          case CommandType.Dialogue: {
            instantAdvance = false;
            const cmd = command;
            const char = cmd.characterId ? project.characters[cmd.characterId] : null;
            setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, isWaitingForInput: true, dialogue: { text: cmd.text, characterName: (char == null ? void 0 : char.name) || "Narrator", characterColor: (char == null ? void 0 : char.color) || "#FFFFFF" } } } : null);
            break;
          }
          case CommandType.SetBackground: {
            instantAdvance = false;
            const cmd = command;
            const newUrl = assetResolver(cmd.backgroundId, "image");
            const { isVideo, loop } = getAssetMetadata(cmd.backgroundId, "image");
            const duration = cmd.duration ?? 1;
            if (!newUrl) {
              console.warn(\`Background not found: \${cmd.backgroundId}\`);
              advance();
              break;
            }
            const preloadMedia = () => new Promise((resolve, reject) => {
              if (isVideo) {
                const video = document.createElement("video");
                video.src = newUrl;
                video.preload = "auto";
                video.onerror = () => reject(new Error(\`Failed to load background video: \${newUrl}\`));
                video.onloadeddata = () => resolve();
              } else {
                const img = new Image();
                img.src = newUrl;
                img.onerror = () => reject(new Error(\`Failed to load background image: \${newUrl}\`));
                img.onload = () => resolve();
              }
            });
            try {
              await preloadMedia();
            } catch (error) {
              console.error(error);
              advance();
              break;
            }
            let transitionElement = null;
            if (cmd.transition === "instant" || !cmd.transition) {
              setPlayerState((p) => p ? {
                ...p,
                stageState: { ...p.stageState, backgroundUrl: newUrl, backgroundIsVideo: isVideo, backgroundLoop: loop },
                currentIndex: p.currentIndex + 1
              } : null);
              break;
            }
            const MediaElement = isVideo ? "video" : "img";
            const mediaProps = isVideo ? { autoPlay: true, muted: true, loop, playsInline: true } : { alt: "" };
            if (cmd.transition === "cross-fade") {
              transitionElement = /* @__PURE__ */ jsxRuntime2.jsx(MediaElement, { src: newUrl, ...mediaProps, className: "absolute inset-0 w-full h-full object-cover z-0", style: { opacity: 0, transition: \`opacity \${duration}s ease-in-out\` } }, Date.now());
              setTimeout(() => {
                setPlayerState((p) => {
                  if (!p) return null;
                  const el = /* @__PURE__ */ jsxRuntime2.jsx(MediaElement, { src: newUrl, ...mediaProps, className: "absolute inset-0 w-full h-full object-cover z-0", style: { opacity: 1, transition: \`opacity \${duration}s ease-in-out\` } }, Date.now());
                  return { ...p, uiState: { ...p.uiState, transitionElement: el } };
                });
              }, 50);
            } else if (cmd.transition === "fade") {
              transitionElement = /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0 z-0 bg-black", style: { animation: \`dissolve-in \${duration / 2}s forwards\` } }, Date.now());
              setTimeout(() => {
                setPlayerState((p) => {
                  if (!p) return null;
                  const el = /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0 z-0 bg-black", style: { animation: \`fade-out \${duration / 2}s forwards\` } }, Date.now() + 1);
                  return { ...p, stageState: { ...p.stageState, backgroundUrl: newUrl, backgroundIsVideo: isVideo, backgroundLoop: loop }, uiState: { ...p.uiState, transitionElement: el } };
                });
              }, duration * 500);
            } else {
              let transitionClass = "";
              switch (cmd.transition) {
                case "dissolve":
                  transitionClass = "transition-dissolve";
                  break;
                case "slide":
                  transitionClass = "transition-slide-in-right";
                  break;
                case "iris-in":
                  transitionClass = "transition-iris-in";
                  break;
                case "wipe-right":
                  transitionClass = "transition-wipe-right";
                  break;
              }
              transitionElement = /* @__PURE__ */ jsxRuntime2.jsx(MediaElement, { src: newUrl, ...mediaProps, className: \`absolute inset-0 w-full h-full object-cover z-0 transition-base \${transitionClass}\`, style: { animationDuration: \`\${duration}s\` } }, Date.now());
            }
            setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, isTransitioning: true, transitionElement } } : null);
            setTimeout(() => {
              setPlayerState((p) => {
                if (!p) return null;
                return {
                  ...p,
                  stageState: { ...p.stageState, backgroundUrl: newUrl, backgroundIsVideo: isVideo, backgroundLoop: loop },
                  // Finalize the background change
                  uiState: { ...p.uiState, isTransitioning: false, transitionElement: null },
                  currentIndex: p.currentIndex + 1
                };
              });
            }, duration * 1e3 + 100);
            break;
          }
          case CommandType.ShowCharacter: {
            const cmd = command;
            const charData = project.characters[cmd.characterId];
            const exprData = charData == null ? void 0 : charData.expressions[cmd.expressionId];
            if (charData && exprData) {
              const imageUrls = [];
              const videoUrls = [];
              let hasVideo = false;
              let videoLoop = false;
              if (charData.baseVideoUrl) {
                videoUrls.push(charData.baseVideoUrl);
                hasVideo = true;
                videoLoop = !!charData.baseVideoLoop;
              } else if (charData.baseImageUrl) {
                imageUrls.push(charData.baseImageUrl);
              }
              const layerBindings = {};
              Object.values(charData.layers).forEach((layer) => {
                const matchingVar = Object.values(project.variables).find(
                  (v) => v.type === "number" && (v.name.toLowerCase().includes(layer.name.toLowerCase()) || layer.name.toLowerCase().includes(v.name.toLowerCase()))
                );
                if (matchingVar) {
                  layerBindings[layer.id] = matchingVar.id;
                }
              });
              const existingChar = playerState == null ? void 0 : playerState.stageState.characters[cmd.characterId];
              const finalBindings = { ...layerBindings, ...(existingChar == null ? void 0 : existingChar.layerVariableBindings) || {} };
              Object.values(charData.layers).forEach((layer) => {
                let asset = null;
                const variableId = finalBindings[layer.id];
                if (variableId && playerState.variables[variableId] !== void 0) {
                  const index = Number(playerState.variables[variableId]) || 0;
                  const assetArray = Object.values(layer.assets);
                  asset = assetArray[index];
                  console.log(\`ShowCharacter: Using variable \${variableId} (value: \${index}) for layer "\${layer.name}"\`);
                } else {
                  const assetId = exprData.layerConfiguration[layer.id];
                  if (assetId) {
                    asset = layer.assets[assetId];
                    console.log(\`ShowCharacter: Using expression config for layer "\${layer.name}"\`);
                  }
                }
                if (asset) {
                  if (asset.videoUrl) {
                    videoUrls.push(asset.videoUrl);
                    hasVideo = true;
                    videoLoop = videoLoop || !!asset.loop;
                  } else if (asset.imageUrl) {
                    imageUrls.push(asset.imageUrl);
                  }
                }
              });
              const finalPosition = cmd.endPosition || cmd.position;
              const startPosition = cmd.startPosition;
              const requestedTransition = cmd.transition;
              console.log(\`ShowCharacter: \${charData.name}, expression: \${exprData.name}, bindings:\`, finalBindings, "variables:", playerState.variables);
              setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, characters: { ...p.stageState.characters, [cmd.characterId]: {
                charId: cmd.characterId,
                position: finalPosition,
                imageUrls,
                videoUrls,
                isVideo: hasVideo,
                videoLoop,
                expressionId: cmd.expressionId,
                layerVariableBindings: finalBindings,
                transition: requestedTransition && requestedTransition !== "instant" ? {
                  type: requestedTransition,
                  duration: cmd.duration ?? 0.5,
                  startPosition,
                  action: "show"
                } : null
              } } } } : null);
              if (cmd.transition && cmd.transition !== "instant") {
                instantAdvance = false;
                setTimeout(() => advance(), (cmd.duration ?? 0.5) * 1e3 + 100);
              }
            }
            break;
          }
          case CommandType.HideCharacter: {
            const cmd = command;
            const hideTransitionType = cmd.transition;
            if (hideTransitionType && hideTransitionType !== "instant") {
              instantAdvance = false;
              setPlayerState((p) => {
                if (!p) return null;
                const existingChar = p.stageState.characters[cmd.characterId];
                if (!existingChar) return p;
                const finalPosition = existingChar.position;
                const startPosition = void 0;
                return {
                  ...p,
                  stageState: {
                    ...p.stageState,
                    characters: {
                      ...p.stageState.characters,
                      [cmd.characterId]: {
                        ...existingChar,
                        position: finalPosition,
                        transition: {
                          type: hideTransitionType,
                          duration: cmd.duration ?? 0.5,
                          startPosition,
                          endPosition: cmd.endPosition,
                          action: "hide"
                        }
                      }
                    }
                  }
                };
              });
              setTimeout(() => {
                setPlayerState((p) => {
                  if (!p) return null;
                  const { [cmd.characterId]: _, ...remaining } = p.stageState.characters;
                  return { ...p, stageState: { ...p.stageState, characters: remaining } };
                });
                advance();
              }, (cmd.duration ?? 0.5) * 1e3 + 100);
            } else {
              setPlayerState((p) => {
                if (!p) return null;
                const { [cmd.characterId]: _, ...remaining } = p.stageState.characters;
                return { ...p, stageState: { ...p.stageState, characters: remaining } };
              });
            }
            break;
          }
          case CommandType.Choice: {
            instantAdvance = false;
            const cmd = command;
            const availableChoices = cmd.options.filter((opt) => evaluateConditions(opt.conditions, playerState.variables));
            setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, choices: availableChoices } } : null);
            break;
          }
          case CommandType.SetVariable: {
            const cmd = command;
            setPlayerState((p) => {
              if (!p) return null;
              const variable = project.variables[cmd.variableId];
              if (!variable) {
                console.warn(\`SetVariable command failed: Variable with ID \${cmd.variableId} not found.\`);
                return { ...p, currentIndex: p.currentIndex + 1 };
              }
              const currentVal = p.variables[cmd.variableId];
              const changeValStr = String(cmd.value);
              let newVal = cmd.value;
              if (cmd.operator === "add") {
                newVal = (Number(currentVal) || 0) + (Number(changeValStr) || 0);
              } else if (cmd.operator === "subtract") {
                newVal = (Number(currentVal) || 0) - (Number(changeValStr) || 0);
              } else if (cmd.operator === "random") {
                const min = cmd.randomMin ?? 0;
                const max = cmd.randomMax ?? 100;
                newVal = Math.floor(Math.random() * (max - min + 1)) + min;
              } else {
                switch (variable.type) {
                  case "number":
                    newVal = Number(changeValStr) || 0;
                    break;
                  case "boolean":
                    if (typeof cmd.value === "boolean") {
                      newVal = cmd.value;
                    } else {
                      const normalized = String(cmd.value).trim().toLowerCase();
                      if (normalized === "true" || normalized === "1") {
                        newVal = true;
                      } else if (normalized === "false" || normalized === "0" || normalized === "") {
                        newVal = false;
                      } else {
                        newVal = !!cmd.value;
                      }
                    }
                    break;
                  case "string":
                  default:
                    newVal = changeValStr;
                    break;
                }
              }
              return {
                ...p,
                variables: { ...p.variables, [cmd.variableId]: newVal },
                currentIndex: p.currentIndex + 1
              };
            });
            instantAdvance = false;
            break;
          }
          case CommandType.TextInput: {
            instantAdvance = false;
            const cmd = command;
            setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, isWaitingForInput: true, textInput: { variableId: cmd.variableId, prompt: cmd.prompt, placeholder: cmd.placeholder || "", maxLength: cmd.maxLength || 50 } } } : null);
            break;
          }
          case CommandType.Jump: {
            const cmd = command;
            const actualSceneId = navigateToScene(cmd.targetSceneId, playerState.variables);
            const newScene = project.scenes[actualSceneId];
            if (newScene) {
              setPlayerState((p) => p ? { ...p, currentSceneId: actualSceneId, currentCommands: newScene.commands, currentIndex: 0, commandStack: [] } : null);
            } else {
              console.error(\`Scene not found: \${actualSceneId}\`);
              advance();
            }
            instantAdvance = false;
            break;
          }
          case CommandType.PlayMusic: {
            const cmd = command;
            console.log("[PlayMusic] Starting music command", { audioId: cmd.audioId, loop: cmd.loop });
            const url = assetResolver(cmd.audioId, "audio");
            if (!url) {
              console.warn(\`No audio URL found for audioId: \${cmd.audioId}\`);
              break;
            }
            const audio = musicAudioRef.current;
            const currentSrcPath = audio.src ? new URL(audio.src, window.location.href).pathname : null;
            const newSrcPath = url ? new URL(url, window.location.href).pathname : null;
            const isNewTrack = currentSrcPath !== newSrcPath;
            console.log("[PlayMusic] Audio setup", { isNewTrack, currentSrc: audio.src, newUrl: url, paused: audio.paused });
            if (!isNewTrack && !audio.paused) {
              console.log("[PlayMusic] Same track already playing, updating state only");
              setPlayerState((p) => p ? {
                ...p,
                musicState: { ...p.musicState, audioId: cmd.audioId, loop: cmd.loop, isPlaying: true }
              } : null);
              break;
            }
            setPlayerState((p) => p ? {
              ...p,
              musicState: { audioId: cmd.audioId, loop: cmd.loop, currentTime: 0, isPlaying: true }
            } : null);
            const startPlayback = () => {
              console.log("[PlayMusic] Starting playback");
              audio.loop = cmd.loop;
              audio.volume = 0;
              audio.play().then(() => {
                console.log("[PlayMusic] Audio playing, starting fade-in");
                const target = typeof cmd.volume === "number" ? cmd.volume : settings.musicVolume;
                fadeAudio(audio, target, cmd.fadeDuration);
              }).catch((e) => {
                console.error("[PlayMusic] Music play failed:", e);
                queuedMusicRef.current = { url, loop: cmd.loop, fadeDuration: cmd.fadeDuration };
              });
            };
            if (isNewTrack) {
              audio.src = url;
              audio.load();
              audio.addEventListener("canplaythrough", startPlayback, { once: true });
              audio.addEventListener("error", (e) => {
                console.error("[PlayMusic] Music load failed:", e);
              }, { once: true });
            } else {
              startPlayback();
            }
            console.log("[PlayMusic] Command complete, advancing");
            break;
          }
          case CommandType.StopMusic: {
            const cmd = command;
            if (musicAudioRef.current) {
              fadeAudio(musicAudioRef.current, 0, cmd.fadeDuration, () => {
                var _a2;
                (_a2 = musicAudioRef.current) == null ? void 0 : _a2.pause();
              });
            }
            setPlayerState((p) => p ? { ...p, musicState: { audioId: null, loop: false, currentTime: 0, isPlaying: false } } : null);
            break;
          }
          case CommandType.PlaySoundEffect: {
            const pse = command;
            try {
              playSound(pse.audioId, pse.volume);
            } catch (e) {
              console.error("Failed to play sound effect:", e);
            }
            break;
          }
          case CommandType.PlayMovie: {
            instantAdvance = false;
            setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, isWaitingForInput: true, movieUrl: assetResolver(command.videoId, "video") } } : null);
            break;
          }
          case CommandType.Wait: {
            instantAdvance = false;
            const cmd = command;
            const durationMs = (cmd.duration ?? 1) * 1e3;
            if (cmd.waitForInput) {
              let timeoutId = window.setTimeout(() => {
                advance();
                removeListeners();
              }, durationMs);
              const onUserAdvance = () => {
                if (timeoutId) {
                  clearTimeout(timeoutId);
                  timeoutId = null;
                }
                advance();
                removeListeners();
              };
              const keyHandler = (e) => {
                if (e.key === " " || e.key === "Enter" || e.key === "Escape") onUserAdvance();
              };
              const clickHandler = () => onUserAdvance();
              const removeListeners = () => {
                window.removeEventListener("keydown", keyHandler);
                window.removeEventListener("click", clickHandler);
              };
              window.addEventListener("keydown", keyHandler);
              window.addEventListener("click", clickHandler);
            } else {
              setTimeout(() => advance(), durationMs);
            }
            break;
          }
          case CommandType.ShakeScreen: {
            const cmd = command;
            setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, screen: { ...p.stageState.screen, shake: { active: true, intensity: cmd.intensity } } } } : null);
            setTimeout(() => setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, screen: { ...p.stageState.screen, shake: { active: false, intensity: 0 } } } } : null), cmd.duration * 1e3);
            break;
          }
          case CommandType.TintScreen: {
            const cmd = command;
            setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, screen: { ...p.stageState.screen, tint: cmd.color, transitionDuration: cmd.duration } } } : null);
            break;
          }
          case CommandType.PanZoomScreen: {
            const cmd = command;
            setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, screen: { ...p.stageState.screen, zoom: cmd.zoom, panX: cmd.panX, panY: cmd.panY, transitionDuration: cmd.duration } } } : null);
            break;
          }
          case CommandType.ResetScreenEffects: {
            const cmd = command;
            setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, screen: { ...p.stageState.screen, tint: "transparent", zoom: 1, panX: 0, panY: 0, transitionDuration: cmd.duration } } } : null);
            break;
          }
          case CommandType.FlashScreen: {
            const cmd = command;
            setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, flash: { color: cmd.color, duration: cmd.duration } } } : null);
            setTimeout(() => setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, flash: null } } : null), cmd.duration * 1e3);
            break;
          }
          case CommandType.ShowScreen: {
            instantAdvance = false;
            const cmd = command;
            if (playerState && playerState.mode === "playing") {
              setHudStack((s) => [...s, cmd.screenId]);
            } else {
              setScreenStack((s) => [...s, cmd.screenId]);
            }
            break;
          }
          case CommandType.ShowText: {
            const cmd = command;
            const interpolatedText = interpolateVariables(cmd.text, playerState.variables, project);
            const overlay = {
              id: cmd.id,
              text: interpolatedText,
              x: cmd.x,
              y: cmd.y,
              fontSize: cmd.fontSize,
              fontFamily: cmd.fontFamily,
              color: cmd.color,
              width: cmd.width,
              height: cmd.height,
              textAlign: cmd.textAlign,
              verticalAlign: cmd.verticalAlign,
              transition: cmd.transition !== "instant" ? cmd.transition : void 0,
              duration: cmd.duration,
              action: "show"
            };
            setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, textOverlays: [...p.stageState.textOverlays, overlay] } } : null);
            if (cmd.transition && cmd.transition !== "instant") {
              instantAdvance = false;
              setTimeout(() => advance(), (cmd.duration ?? 0.5) * 1e3 + 100);
            }
            break;
          }
          case CommandType.ShowImage: {
            const cmd = command;
            const imageUrl = assetResolver(cmd.imageId, "image");
            const { isVideo, loop } = getAssetMetadata(cmd.imageId, "image");
            if (imageUrl) {
              const overlay = {
                id: cmd.id,
                imageUrl: !isVideo ? imageUrl : void 0,
                videoUrl: isVideo ? imageUrl : void 0,
                isVideo,
                videoLoop: loop,
                x: cmd.x,
                y: cmd.y,
                width: cmd.width,
                height: cmd.height,
                rotation: cmd.rotation,
                opacity: cmd.opacity,
                scaleX: cmd.scaleX ?? 1,
                scaleY: cmd.scaleY ?? 1,
                transition: cmd.transition !== "instant" ? cmd.transition : void 0,
                duration: cmd.duration,
                action: "show"
              };
              setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, imageOverlays: [...p.stageState.imageOverlays, overlay] } } : null);
              if (cmd.transition && cmd.transition !== "instant") {
                instantAdvance = false;
                setTimeout(() => advance(), (cmd.duration ?? 0.5) * 1e3 + 100);
              }
            } else {
              console.warn(\`Image not found: \${cmd.imageId}\`);
            }
            break;
          }
          case CommandType.Label: {
            break;
          }
          case CommandType.JumpToLabel: {
            const cmd = command;
            const labelIndex = playerState.currentCommands.findIndex((c) => c.type === CommandType.Label && c.labelId === cmd.labelId);
            if (labelIndex !== -1) {
              setPlayerState((p) => p ? { ...p, currentIndex: labelIndex } : null);
            } else {
              console.warn(\`Label not found: \${cmd.labelId}\`);
              advance();
            }
            instantAdvance = false;
            break;
          }
          case CommandType.HideText: {
            const cmd = command;
            setPlayerState((p) => {
              if (!p) return null;
              const overlays = p.stageState.textOverlays;
              const target = overlays.find((o) => o.id === cmd.targetCommandId);
              if (!target) return p;
              if (cmd.transition && cmd.transition !== "instant") {
                const updated = overlays.map((o) => o.id === cmd.targetCommandId ? { ...o, transition: cmd.transition, duration: cmd.duration, action: "hide" } : o);
                setTimeout(() => {
                  setPlayerState((inner) => inner ? { ...inner, stageState: { ...inner.stageState, textOverlays: inner.stageState.textOverlays.filter((o) => o.id !== cmd.targetCommandId) } } : null);
                  advance();
                }, (cmd.duration ?? 0.5) * 1e3 + 100);
                instantAdvance = false;
                return { ...p, stageState: { ...p.stageState, textOverlays: updated } };
              } else {
                return { ...p, stageState: { ...p.stageState, textOverlays: overlays.filter((o) => o.id !== cmd.targetCommandId) } };
              }
            });
            break;
          }
          case CommandType.HideImage: {
            const cmd = command;
            setPlayerState((p) => {
              if (!p) return null;
              const overlays = p.stageState.imageOverlays;
              const target = overlays.find((o) => o.id === cmd.targetCommandId);
              if (!target) return p;
              if (cmd.transition && cmd.transition !== "instant") {
                const updated = overlays.map((o) => o.id === cmd.targetCommandId ? { ...o, transition: cmd.transition, duration: cmd.duration, action: "hide" } : o);
                setTimeout(() => {
                  setPlayerState((inner) => inner ? { ...inner, stageState: { ...inner.stageState, imageOverlays: inner.stageState.imageOverlays.filter((o) => o.id !== cmd.targetCommandId) } } : null);
                  advance();
                }, (cmd.duration ?? 0.5) * 1e3 + 100);
                instantAdvance = false;
                return { ...p, stageState: { ...p.stageState, imageOverlays: updated } };
              } else {
                return { ...p, stageState: { ...p.stageState, imageOverlays: overlays.filter((o) => o.id !== cmd.targetCommandId) } };
              }
            });
            break;
          }
          case CommandType.ShowButton: {
            const cmd = command;
            if (cmd.showConditions && cmd.showConditions.length > 0) {
              const conditionsMet = cmd.showConditions.every((cond) => evaluateConditions([cond]));
              if (!conditionsMet) {
                break;
              }
            }
            const buttonOverlay = {
              id: cmd.id,
              text: cmd.text,
              x: cmd.x,
              y: cmd.y,
              width: cmd.width || 20,
              height: cmd.height || 8,
              anchorX: cmd.anchorX || 0.5,
              anchorY: cmd.anchorY || 0.5,
              backgroundColor: cmd.backgroundColor || "#6366f1",
              textColor: cmd.textColor || "#ffffff",
              fontSize: cmd.fontSize || 18,
              fontWeight: cmd.fontWeight || "normal",
              borderRadius: cmd.borderRadius || 8,
              imageUrl: cmd.image ? assetResolver(cmd.image.id, cmd.image.type) : null,
              hoverImageUrl: cmd.hoverImage ? assetResolver(cmd.hoverImage.id, cmd.hoverImage.type) : null,
              onClick: cmd.onClick,
              clickSound: cmd.clickSound,
              waitForClick: cmd.waitForClick,
              transition: cmd.transition !== "instant" ? cmd.transition : void 0,
              duration: cmd.duration || 0.3,
              action: "show"
            };
            setPlayerState((p) => p ? { ...p, stageState: { ...p.stageState, buttonOverlays: [...p.stageState.buttonOverlays, buttonOverlay] } } : null);
            if (cmd.transition && cmd.transition !== "instant") {
              instantAdvance = false;
              if (cmd.waitForClick) {
                setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, isWaitingForInput: true } } : null);
              } else {
                setTimeout(() => advance(), (cmd.duration ?? 0.3) * 1e3 + 100);
              }
            } else if (cmd.waitForClick) {
              instantAdvance = false;
              setPlayerState((p) => p ? { ...p, uiState: { ...p.uiState, isWaitingForInput: true } } : null);
            }
            break;
          }
          case CommandType.HideButton: {
            const cmd = command;
            setPlayerState((p) => {
              if (!p) return null;
              const overlays = p.stageState.buttonOverlays;
              const target = overlays.find((o) => o.id === cmd.targetCommandId);
              if (!target) return p;
              if (cmd.transition && cmd.transition !== "instant") {
                const updated = overlays.map((o) => o.id === cmd.targetCommandId ? { ...o, transition: cmd.transition, duration: cmd.duration || 0.3, action: "hide" } : o);
                setTimeout(() => {
                  setPlayerState((inner) => inner ? { ...inner, stageState: { ...inner.stageState, buttonOverlays: inner.stageState.buttonOverlays.filter((o) => o.id !== cmd.targetCommandId) } } : null);
                  advance();
                }, (cmd.duration ?? 0.3) * 1e3 + 100);
                instantAdvance = false;
                return { ...p, stageState: { ...p.stageState, buttonOverlays: updated } };
              } else {
                return { ...p, stageState: { ...p.stageState, buttonOverlays: overlays.filter((o) => o.id !== cmd.targetCommandId) } };
              }
            });
            break;
          }
        }
        if (shouldRunAsync) {
          advance();
        } else if (instantAdvance) {
          advance();
        }
      })();
    }, [playerState, project, assetResolver, playSound, evaluateConditions, fadeAudio, settings.musicVolume, startNewGame, stopAndResetMusic, stopAllSfx, hudStack]);
    const handleDialogueAdvance = () => {
      setPlayerState((p) => p ? { ...p, currentIndex: p.currentIndex + 1, uiState: { ...p.uiState, isWaitingForInput: false, dialogue: null } } : null);
    };
    const handleChoiceSelect = (choice) => {
      var _a;
      console.log("[CHOICE] Selected:", choice.text, "Actions:", ((_a = choice.actions) == null ? void 0 : _a.length) || 0);
      setPlayerState((p) => {
        if (!p) return null;
        let newState = { ...p };
        const actions = choice.actions || [];
        if (!choice.actions && choice.targetSceneId) {
          actions.push({ type: UIActionType.JumpToScene, targetSceneId: choice.targetSceneId });
        }
        for (const action of actions) {
          if (action.type === UIActionType.SetVariable) {
            const setVarAction = action;
            const variable = project.variables[setVarAction.variableId];
            if (!variable) {
              console.warn(\`SetVariable action failed: Variable with ID \${setVarAction.variableId} not found.\`);
              continue;
            }
            const currentVal = newState.variables[setVarAction.variableId];
            const changeValStr = String(setVarAction.value);
            let newVal = setVarAction.value;
            if (setVarAction.operator === "add") {
              newVal = (Number(currentVal) || 0) + (Number(changeValStr) || 0);
            } else if (setVarAction.operator === "subtract") {
              newVal = (Number(currentVal) || 0) - (Number(changeValStr) || 0);
            } else if (setVarAction.operator === "random") {
              const min = setVarAction.randomMin ?? 0;
              const max = setVarAction.randomMax ?? 100;
              newVal = Math.floor(Math.random() * (max - min + 1)) + min;
            } else {
              switch (variable.type) {
                case "number":
                  newVal = Number(changeValStr) || 0;
                  break;
                case "boolean":
                  if (typeof setVarAction.value === "boolean") {
                    newVal = setVarAction.value;
                  } else {
                    const normalized = String(setVarAction.value).trim().toLowerCase();
                    if (normalized === "true" || normalized === "1") {
                      newVal = true;
                    } else if (normalized === "false" || normalized === "0" || normalized === "") {
                      newVal = false;
                    } else {
                      newVal = !!setVarAction.value;
                    }
                  }
                  break;
                case "string":
                default:
                  newVal = changeValStr;
                  break;
              }
            }
            newState.variables = { ...newState.variables, [setVarAction.variableId]: newVal };
          }
        }
        newState.uiState = { ...newState.uiState, choices: null };
        const jumpAction = actions.find((a) => a.type === UIActionType.JumpToScene);
        if (jumpAction) {
          const actualSceneId = navigateToScene(jumpAction.targetSceneId, newState.variables);
          const newScene = project.scenes[actualSceneId];
          if (newScene) {
            newState.currentSceneId = actualSceneId;
            newState.currentCommands = newScene.commands;
            newState.currentIndex = 0;
          } else {
            console.error(\`Scene not found for choice jump: \${actualSceneId}\`);
            newState.currentIndex = newState.currentIndex + 1;
          }
        } else {
          newState.currentIndex = newState.currentIndex + 1;
        }
        return newState;
      });
    };
    const handleTextInputSubmit = (value) => {
      setPlayerState((p) => p ? {
        ...p,
        currentIndex: p.currentIndex + 1,
        variables: { ...p.variables, [p.uiState.textInput.variableId]: value },
        uiState: { ...p.uiState, isWaitingForInput: false, textInput: null }
      } : null);
    };
    const handleUIAction = (action) => {
      console.log("handleUIAction called with:", action.type, action);
      if (!playerState && action.type === UIActionType.StartNewGame) {
        startNewGame();
      } else if ((playerState == null ? void 0 : playerState.mode) === "paused" && action.type === UIActionType.ReturnToGame) {
        setPlayerState((p) => p ? { ...p, mode: "playing" } : null);
        setScreenStack([]);
        if (musicAudioRef.current && musicAudioRef.current.paused && playerState.musicState.isPlaying) {
          musicAudioRef.current.play().catch((e) => console.error("Failed to resume music:", e));
        }
      } else if (action.type === UIActionType.GoToScreen) {
        const targetId = action.targetScreenId;
        if (playerState && playerState.mode === "playing") {
          setHudStack((s) => [...s, targetId]);
        } else {
          setScreenStack((stack) => [...stack, targetId]);
        }
      } else if (action.type === UIActionType.ReturnToPreviousScreen) {
        if (playerState && playerState.mode === "playing") {
          if (hudStack.length > 0) {
            setHudStack((s) => s.slice(0, -1));
            if (hudStack.length === 1) {
              setPlayerState((p) => {
                if (!p) return null;
                return {
                  ...p,
                  currentIndex: p.currentIndex + 1,
                  stageState: {
                    ...p.stageState,
                    buttonOverlays: [],
                    imageOverlays: []
                  }
                };
              });
            }
          }
        } else {
          if (screenStack.length > 1) setScreenStack((stack) => stack.slice(0, -1));
        }
      } else if (action.type === UIActionType.QuitToTitle) {
        stopAndResetMusic();
        stopAllSfx();
        setPlayerState(null);
        setHudStack([]);
        if (project.ui.titleScreenId) setScreenStack([project.ui.titleScreenId]);
      } else if (action.type === UIActionType.SaveGame) {
        saveGame(action.slotNumber);
      } else if (action.type === UIActionType.LoadGame) {
        loadGame(action.slotNumber);
      } else if (action.type === UIActionType.JumpToScene) {
        const jumpAction = action;
        const targetScene = project.scenes[jumpAction.targetSceneId];
        console.log("JumpToScene handler triggered:", {
          targetSceneId: jumpAction.targetSceneId,
          sceneExists: !!targetScene,
          sceneName: targetScene == null ? void 0 : targetScene.name,
          currentSceneId: playerState == null ? void 0 : playerState.currentSceneId,
          hasPlayerState: !!playerState
        });
        if (!targetScene) {
          console.warn(\`JumpToScene action failed: Scene with ID \${jumpAction.targetSceneId} not found.\`);
          return;
        }
        const audio = musicAudioRef.current;
        if (!audio.paused) {
          fadeAudio(audio, 0, 0.5, () => {
            audio.pause();
            audio.currentTime = 0;
          });
        }
        setScreenStack([]);
        setHudStack([]);
        lastProcessedCommandRef.current = null;
        if (!playerState) {
          console.log("Initializing playerState for scene jump from title");
          const initialVariables = {};
          for (const varId in project.variables) {
            const v = project.variables[varId];
            initialVariables[v.id] = v.defaultValue;
          }
          setPlayerState({
            mode: "playing",
            currentSceneId: jumpAction.targetSceneId,
            currentCommands: targetScene.commands,
            currentIndex: 0,
            commandStack: [],
            variables: initialVariables,
            stageState: {
              backgroundUrl: null,
              characters: {},
              textOverlays: [],
              imageOverlays: [],
              buttonOverlays: [],
              screen: {
                shake: { active: false, intensity: 0 },
                tint: "transparent",
                zoom: 1,
                panX: 0,
                panY: 0,
                transitionDuration: 0.5
              }
            },
            uiState: {
              dialogue: null,
              choices: null,
              textInput: null,
              movieUrl: null,
              isWaitingForInput: false,
              isTransitioning: false,
              transitionElement: null,
              flash: null
            },
            musicState: {
              audioId: null,
              isPlaying: false,
              loop: false,
              currentTime: 0
            }
          });
        } else {
          console.log("Jumping to new scene from existing game state");
          setPlayerState((p) => {
            if (!p) return null;
            console.log("Setting new scene:", {
              targetSceneId: jumpAction.targetSceneId,
              commandCount: targetScene.commands.length,
              commands: targetScene.commands.map((c) => ({ type: c.type, id: c.id }))
            });
            return {
              ...p,
              currentSceneId: jumpAction.targetSceneId,
              currentCommands: targetScene.commands,
              currentIndex: 0,
              // Reset stage state to clean slate
              stageState: {
                backgroundUrl: null,
                characters: {},
                textOverlays: [],
                imageOverlays: [],
                buttonOverlays: [],
                screen: {
                  shake: { active: false, intensity: 0 },
                  tint: "transparent",
                  zoom: 1,
                  panX: 0,
                  panY: 0,
                  transitionDuration: 0.5
                }
              },
              // Clear any active UI state (dialogue, choices, etc.)
              uiState: {
                dialogue: null,
                choices: null,
                textInput: null,
                movieUrl: null,
                isWaitingForInput: false,
                isTransitioning: false,
                transitionElement: null,
                flash: null
              }
            };
          });
        }
      } else if (action.type === UIActionType.SetVariable && playerState) {
        const setVarAction = action;
        const variable = project.variables[setVarAction.variableId];
        if (!variable) {
          console.warn(\`SetVariable action failed: Variable with ID \${setVarAction.variableId} not found.\`);
          return;
        }
        setPlayerState((p) => {
          if (!p) return null;
          const currentVal = p.variables[setVarAction.variableId];
          const changeValStr = String(setVarAction.value);
          let newVal = setVarAction.value;
          if (setVarAction.operator === "add") {
            newVal = (Number(currentVal) || 0) + (Number(changeValStr) || 0);
          } else if (setVarAction.operator === "subtract") {
            newVal = (Number(currentVal) || 0) - (Number(changeValStr) || 0);
          } else if (setVarAction.operator === "random") {
            const min = setVarAction.randomMin ?? 0;
            const max = setVarAction.randomMax ?? 100;
            newVal = Math.floor(Math.random() * (max - min + 1)) + min;
          } else {
            switch (variable.type) {
              case "number":
                newVal = Number(changeValStr) || 0;
                break;
              case "boolean":
                newVal = changeValStr.toLowerCase() === "true";
                break;
              case "string":
              default:
                newVal = changeValStr;
                break;
            }
          }
          return { ...p, variables: { ...p.variables, [setVarAction.variableId]: newVal } };
        });
      } else if (action.type === UIActionType.CycleLayerAsset) {
        console.log("CycleLayerAsset handler triggered, playerState exists:", !!playerState);
        const cycleAction = action;
        console.log("CycleLayerAsset action details:", {
          characterId: cycleAction.characterId,
          layerId: cycleAction.layerId,
          variableId: cycleAction.variableId,
          direction: cycleAction.direction
        });
        const character = project.characters[cycleAction.characterId];
        if (!character) {
          console.warn(\`CycleLayerAsset action failed: Character with ID \${cycleAction.characterId} not found.\`);
          return;
        }
        console.log("Character found:", character.name);
        const layer = character.layers[cycleAction.layerId];
        if (!layer) {
          console.warn(\`CycleLayerAsset action failed: Layer with ID \${cycleAction.layerId} not found.\`);
          return;
        }
        console.log("Layer found:", layer.name);
        const assetsCount = Object.keys(layer.assets || {}).length;
        console.log("Assets count:", assetsCount);
        if (assetsCount === 0) {
          console.warn(\`CycleLayerAsset action failed: Layer "\${layer.name}" has no assets.\`);
          return;
        }
        if (playerState) {
          setPlayerState((p) => {
            if (!p) return null;
            const currentIndex = Number(p.variables[cycleAction.variableId]) || 0;
            let newIndex;
            if (cycleAction.direction === "next") {
              newIndex = (currentIndex + 1) % assetsCount;
            } else {
              newIndex = (currentIndex - 1 + assetsCount) % assetsCount;
            }
            console.log(\`CycleLayerAsset (in-game): \${character.name} layer "\${layer.name}" from index \${currentIndex} to \${newIndex} (\${cycleAction.direction}), total assets: \${assetsCount}\`);
            return {
              ...p,
              variables: { ...p.variables, [cycleAction.variableId]: newIndex }
            };
          });
        } else {
          const currentIndex = Number(menuVariables[cycleAction.variableId]) || 0;
          let newIndex;
          if (cycleAction.direction === "next") {
            newIndex = (currentIndex + 1) % assetsCount;
          } else {
            newIndex = (currentIndex - 1 + assetsCount) % assetsCount;
          }
          console.log(\`CycleLayerAsset (menu): \${character.name} layer "\${layer.name}" from index \${currentIndex} to \${newIndex} (\${cycleAction.direction}), total assets: \${assetsCount}\`);
          setMenuVariables((vars) => ({
            ...vars,
            [cycleAction.variableId]: newIndex
          }));
        }
      }
    };
    const handleVariableChange = (variableId, value) => {
      if (playerState) {
        setPlayerState((prev) => {
          if (!prev) return prev;
          return {
            ...prev,
            variables: {
              ...prev.variables,
              [variableId]: value
            }
          };
        });
      } else {
        setMenuVariables((prev) => ({
          ...prev,
          [variableId]: value
        }));
      }
    };
    React2.useEffect(() => {
      const handleKeyDown = (e) => {
        if (e.key === "Escape" && playerState) {
          if (playerState.mode === "playing") {
            setPlayerState((p) => p ? { ...p, mode: "paused" } : null);
            if (musicAudioRef.current && !musicAudioRef.current.paused) {
              musicAudioRef.current.pause();
            }
            if (project.ui.pauseScreenId) {
              setScreenStack([project.ui.pauseScreenId]);
            }
          } else if (playerState.mode === "paused") {
            if (screenStack.length > 1) {
              setScreenStack((s) => s.slice(0, -1));
            } else {
              setPlayerState((p) => p ? { ...p, mode: "playing" } : null);
              if (musicAudioRef.current && musicAudioRef.current.src && playerState.musicState.isPlaying) {
                musicAudioRef.current.play().catch((e2) => console.error("Failed to resume music:", e2));
              }
              setScreenStack([]);
            }
          }
        }
      };
      window.addEventListener("keydown", handleKeyDown);
      return () => window.removeEventListener("keydown", handleKeyDown);
    }, [playerState, project.ui.pauseScreenId, screenStack]);
    const renderStage = () => {
      if (!playerState) return null;
      const state = playerState.stageState;
      const getPositionStyle = (position) => {
        if (typeof position === "object") {
          return {
            left: \`\${position.x}%\`,
            top: \`\${position.y}%\`
          };
        } else {
          const presetStyles = {
            "left": { top: "10%", left: "25%" },
            "center": { top: "10%", left: "50%" },
            "right": { top: "10%", left: "75%" },
            "off-left": { top: "10%", left: "-25%" },
            "off-right": { top: "10%", left: "125%" }
          };
          return presetStyles[position];
        }
      };
      const shakeClass = state.screen.shake.active ? "shake" : "";
      const intensityPx = state.screen.shake.intensity * 1.5;
      const panZoomStyle = { transform: \`scale(\${state.screen.zoom}) translate(\${state.screen.panX}%, \${state.screen.panY}%)\`, transition: \`transform \${state.screen.transitionDuration}s ease-in-out\`, width: "100%", height: "100%" };
      const shakeIntensityStyle = state.screen.shake.active ? { "--shake-intensity-x": \`\${intensityPx}px\`, "--shake-intensity-y": \`\${intensityPx * 0.7}px\` } : {};
      const tintStyle = { backgroundColor: state.screen.tint, transition: \`background-color \${state.screen.transitionDuration}s ease-in-out\` };
      return /* @__PURE__ */ jsxRuntime2.jsxs("div", { ref: stageRef, className: "w-full h-full relative overflow-hidden bg-black", children: [
        /* @__PURE__ */ jsxRuntime2.jsx("div", { style: panZoomStyle, children: /* @__PURE__ */ jsxRuntime2.jsxs("div", { className: \`w-full h-full \${shakeClass} z-10\`, style: shakeIntensityStyle, children: [
          state.backgroundUrl && (state.backgroundIsVideo ? /* @__PURE__ */ jsxRuntime2.jsx(
            "video",
            {
              src: state.backgroundUrl,
              autoPlay: true,
              muted: true,
              loop: state.backgroundLoop,
              playsInline: true,
              className: "absolute w-full h-full object-cover"
            }
          ) : /* @__PURE__ */ jsxRuntime2.jsx("img", { src: state.backgroundUrl, alt: "background", className: "absolute w-full h-full object-cover" })),
          playerState == null ? void 0 : playerState.uiState.transitionElement,
          Object.values(state.characters).map((char) => {
            var _a;
            let transitionClass = "";
            let animationDuration = "1s";
            let slideStyle = {};
            let positionStyle = getPositionStyle(char.position);
            if (!char.transition || char.transition.type !== "slide") {
              positionStyle = { ...positionStyle, transform: "translate3d(-50%, 0, 0)" };
            }
            if (char.transition) {
              const isHideTransition = char.transition.action === "hide";
              switch (char.transition.type) {
                case "fade":
                  transitionClass = isHideTransition ? "transition-fade-out" : "transition-dissolve";
                  break;
                case "dissolve":
                  transitionClass = isHideTransition ? "transition-dissolve-out" : "transition-dissolve";
                  break;
                case "slide":
                  transitionClass = "transition-slide";
                  const startPos = char.transition.startPosition || char.position;
                  const endPos = char.transition.endPosition || char.position;
                  let startOffsetX = 0;
                  let startOffsetY = 0;
                  if (typeof startPos === "object" && typeof endPos === "object") {
                    startOffsetX = startPos.x - endPos.x;
                    startOffsetY = startPos.y - endPos.y;
                  } else {
                    const startPreset = typeof startPos === "string" ? startPos : "center";
                    const endPreset = typeof endPos === "string" ? endPos : "center";
                    const presetCoords = {
                      "left": { x: 25, y: 10 },
                      "center": { x: 50, y: 10 },
                      "right": { x: 75, y: 10 },
                      "off-left": { x: -25, y: 10 },
                      "off-right": { x: 125, y: 10 }
                    };
                    const startCoords = presetCoords[startPreset];
                    const endCoords = presetCoords[endPreset];
                    startOffsetX = startCoords.x - endCoords.x;
                    startOffsetY = startCoords.y - endCoords.y;
                  }
                  if (startOffsetX === 0 && ((_a = char.transition) == null ? void 0 : _a.action) === "show") {
                    let endX = 50;
                    if (typeof endPos === "object") endX = endPos.x;
                    else if (typeof endPos === "string") {
                      const presetMap = { left: 25, center: 50, right: 75, "off-left": -25, "off-right": 125 };
                      endX = presetMap[endPos] ?? 50;
                    }
                    startOffsetX = endX <= 50 ? -60 : 60;
                  }
                  slideStyle = {
                    "--slide-start-x": \`\${startOffsetX}%\`,
                    "--slide-start-y": \`\${startOffsetY}%\`,
                    "--slide-end-x": \`0%\`,
                    "--slide-end-y": \`0%\`
                  };
                  if (stageSize && stageSize.width > 0) {
                    const pxStartX = startOffsetX / 100 * stageSize.width;
                    const pxStartY = startOffsetY / 100 * stageSize.height;
                    slideStyle["--slide-start-px"] = \`\${pxStartX}px\`;
                    slideStyle["--slide-end-px"] = \`0px\`;
                    slideStyle["--slide-start-py"] = \`\${pxStartY}px\`;
                    slideStyle["--slide-end-py"] = \`0px\`;
                  }
                  break;
                case "iris-in":
                  transitionClass = isHideTransition ? "transition-iris-out" : "transition-iris-in";
                  break;
                case "wipe-right":
                  transitionClass = isHideTransition ? "transition-wipe-out-right" : "transition-wipe-right";
                  break;
              }
              animationDuration = \`\${char.transition.duration}s\`;
            }
            return /* @__PURE__ */ jsxRuntime2.jsx("div", { className: \`absolute h-[90%] w-auto aspect-[3/4] \${transitionClass} transition-base\`, style: { ...positionStyle, animationDuration, ...slideStyle }, children: char.isVideo && char.videoUrls ? char.videoUrls.map((url, index) => /* @__PURE__ */ jsxRuntime2.jsx(
              "video",
              {
                src: url,
                autoPlay: true,
                muted: true,
                loop: char.videoLoop,
                playsInline: true,
                className: "absolute top-0 left-0 w-full h-full object-contain",
                style: { zIndex: index }
              },
              index
            )) : char.imageUrls.map((url, index) => /* @__PURE__ */ jsxRuntime2.jsx(
              "img",
              {
                src: url,
                alt: "",
                className: "absolute top-0 left-0 w-full h-full object-contain",
                style: { zIndex: index }
              },
              index
            )) }, char.charId);
          }),
          state.textOverlays.map((overlay) => /* @__PURE__ */ jsxRuntime2.jsx(TextOverlayElement, { overlay, stageSize }, overlay.id)),
          state.imageOverlays.map((overlay) => /* @__PURE__ */ jsxRuntime2.jsx(ImageOverlayElement, { overlay, stageSize }, overlay.id)),
          state.buttonOverlays.map((overlay) => /* @__PURE__ */ jsxRuntime2.jsx(
            ButtonOverlayElement,
            {
              overlay,
              onAction: handleUIAction,
              playSound,
              onAdvance: overlay.waitForClick ? () => {
                setPlayerState((p) => {
                  if (!p) return null;
                  return {
                    ...p,
                    currentIndex: p.currentIndex + 1,
                    uiState: { ...p.uiState, isWaitingForInput: false }
                  };
                });
              } : void 0
            },
            overlay.id
          ))
        ] }) }),
        /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0 pointer-events-none", style: tintStyle })
      ] });
    };
    const renderPlayerUI = () => {
      if (!playerState || playerState.mode !== "playing") return null;
      const { uiState } = playerState;
      return /* @__PURE__ */ jsxRuntime2.jsxs(jsxRuntime2.Fragment, { children: [
        uiState.movieUrl && /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0 bg-black z-40 flex flex-col items-center justify-center text-white", onClick: () => setPlayerState((p) => p ? { ...p, currentIndex: p.currentIndex + 1, uiState: { ...p.uiState, isWaitingForInput: false, movieUrl: null } } : null), children: /* @__PURE__ */ jsxRuntime2.jsx("video", { src: uiState.movieUrl, autoPlay: true, className: "w-full h-full", onEnded: () => setPlayerState((p) => p ? { ...p, currentIndex: p.currentIndex + 1, uiState: { ...p.uiState, isWaitingForInput: false, movieUrl: null } } : null) }) }),
        uiState.dialogue && /* @__PURE__ */ jsxRuntime2.jsx(DialogueBox, { dialogue: uiState.dialogue, settings, projectUI: project.ui, onFinished: handleDialogueAdvance, variables: playerState.variables, project }),
        uiState.choices && /* @__PURE__ */ jsxRuntime2.jsx(ChoiceMenu, { choices: uiState.choices, projectUI: project.ui, onSelect: handleChoiceSelect, variables: playerState.variables, project }),
        uiState.textInput && /* @__PURE__ */ jsxRuntime2.jsx(TextInputForm, { textInput: uiState.textInput, onSubmit: handleTextInputSubmit, variables: playerState.variables, project }),
        uiState.flash && /* @__PURE__ */ jsxRuntime2.jsx("div", { className: "absolute inset-0 z-50", style: { backgroundColor: uiState.flash.color, animation: \`flash-anim \${uiState.flash.duration}s ease-in-out\` } })
      ] });
    };
    const currentScreenId = !playerState || playerState.mode === "paused" ? screenStack.length > 0 ? screenStack[screenStack.length - 1] : null : null;
    const handleClose = () => {
      const audio = musicAudioRef.current;
      if (audio) {
        audio.pause();
        audio.currentTime = 0;
        audio.src = "";
      }
      const ambientAudio = ambientNoiseAudioRef.current;
      if (ambientAudio) {
        ambientAudio.pause();
        ambientAudio.currentTime = 0;
        ambientAudio.src = "";
      }
      if (audioFadeInterval.current) {
        clearInterval(audioFadeInterval.current);
        audioFadeInterval.current = null;
      }
      if (ambientFadeInterval.current) {
        clearInterval(ambientFadeInterval.current);
        ambientFadeInterval.current = null;
      }
      stopAllSfx();
      onClose();
    };
    React2.useEffect(() => {
      return () => {
        const audio = musicAudioRef.current;
        if (audio) {
          audio.pause();
          audio.src = "";
        }
        const ambientAudio = ambientNoiseAudioRef.current;
        if (ambientAudio) {
          ambientAudio.pause();
          ambientAudio.src = "";
        }
        if (audioFadeInterval.current) {
          clearInterval(audioFadeInterval.current);
        }
        if (ambientFadeInterval.current) {
          clearInterval(ambientFadeInterval.current);
        }
        sfxSourceNodesRef.current.forEach((src) => {
          try {
            src.stop();
          } catch (e) {
          }
        });
        sfxSourceNodesRef.current = [];
      };
    }, []);
    if (!titleScreenId) {
      return /* @__PURE__ */ jsxRuntime2.jsxs("div", { className: "fixed inset-0 bg-black z-50 flex flex-col items-center justify-center text-white p-8 text-center", children: [
        /* @__PURE__ */ jsxRuntime2.jsx("h2", { className: "text-2xl text-red-500 font-bold mb-4", children: "Playback Error" }),
        /* @__PURE__ */ jsxRuntime2.jsx("p", { className: "max-w-md", children: "Could not start the game because no valid Title Screen is set. Please ensure a Title Screen exists and is configured in the Project Settings." }),
        /* @__PURE__ */ jsxRuntime2.jsx("button", { onClick: handleClose, className: "mt-8 bg-[var(--bg-tertiary)] hover:bg-[var(--accent-purple)] px-6 py-2 rounded-lg font-bold", children: "Return to Editor" })
      ] });
    }
    return /* @__PURE__ */ jsxRuntime2.jsxs("div", { className: "fixed inset-0 bg-black z-50 flex items-center justify-center", children: [
      /* @__PURE__ */ jsxRuntime2.jsxs("div", { className: "w-full h-full aspect-video relative", children: [
        (playerState == null ? void 0 : playerState.mode) === "playing" ? renderStage() : null,
        currentScreenId && /* @__PURE__ */ jsxRuntime2.jsx(
          UIScreenRenderer,
          {
            screenId: currentScreenId,
            onAction: handleUIAction,
            settings,
            onSettingsChange: (key, value) => setSettings((s) => ({ ...s, [key]: value })),
            assetResolver,
            gameSaves,
            playSound,
            variables: (playerState == null ? void 0 : playerState.variables) || menuVariables,
            onVariableChange: handleVariableChange
          }
        ),
        // Render HUD screens while in playing mode. Priority: explicit hudStack top, then project.ui.gameHudScreenId
        (playerState == null ? void 0 : playerState.mode) === "playing" && (() => {
          const hudScreenId = hudStack.length > 0 ? hudStack[hudStack.length - 1] : project.ui.gameHudScreenId;
          return hudScreenId ? /* @__PURE__ */ jsxRuntime2.jsx(
            UIScreenRenderer,
            {
              screenId: hudScreenId,
              onAction: handleUIAction,
              settings,
              onSettingsChange: (key, value) => setSettings((s) => ({ ...s, [key]: value })),
              assetResolver,
              gameSaves,
              playSound,
              variables: (playerState == null ? void 0 : playerState.variables) || menuVariables,
              onVariableChange: handleVariableChange
            }
          ) : null;
        })(),
        renderPlayerUI()
      ] }),
      !hideCloseButton && /* @__PURE__ */ jsxRuntime2.jsx("button", { onClick: handleClose, className: "absolute top-4 right-4 bg-slate-800/50 p-2 rounded-full hover:bg-slate-700/80 transition-colors z-50", children: /* @__PURE__ */ jsxRuntime2.jsx(XMarkIcon, { className: "w-8 h-8" }) })
    ] });
  };
  const flourishLogo = "data:image/png;base64,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";
  const StandalonePlayer = ({ project }) => {
    const [isReady, setIsReady] = React2.useState(false);
    const [showSplash, setShowSplash] = React2.useState(true);
    const [splashFadingOut, setSplashFadingOut] = React2.useState(false);
    React2.useEffect(() => {
      console.log("[Standalone Player] Loaded project:", project.title);
      setIsReady(true);
      const preventContextMenu = (e) => {
        e.preventDefault();
      };
      document.addEventListener("contextmenu", preventContextMenu);
      return () => {
        document.removeEventListener("contextmenu", preventContextMenu);
      };
    }, [project]);
    const handleSplashClick = () => {
      setSplashFadingOut(true);
      setTimeout(() => {
        setShowSplash(false);
      }, 800);
    };
    if (!isReady) {
      return /* @__PURE__ */ jsxRuntime2.jsx("div", { style: {
        width: "100vw",
        height: "100vh",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        background: "#1a1a2e",
        color: "#fff"
      }, children: /* @__PURE__ */ jsxRuntime2.jsx("div", { children: "Initializing game..." }) });
    }
    if (showSplash) {
      return /* @__PURE__ */ jsxRuntime2.jsxs(
        "div",
        {
          onClick: handleSplashClick,
          style: {
            width: "100vw",
            height: "100vh",
            display: "flex",
            flexDirection: "column",
            alignItems: "center",
            justifyContent: "center",
            background: "#000",
            cursor: "pointer",
            opacity: splashFadingOut ? 0 : 1,
            transition: "opacity 0.8s ease-in-out"
          },
          children: [
            /* @__PURE__ */ jsxRuntime2.jsxs("div", { style: {
              textAlign: "center",
              animation: splashFadingOut ? "none" : "fadeIn 1s ease-in"
            }, children: [
              /* @__PURE__ */ jsxRuntime2.jsx("p", { style: {
                color: "#fff",
                fontSize: "1.5rem",
                fontFamily: "sans-serif",
                marginBottom: "2rem",
                letterSpacing: "0.2em",
                fontWeight: "300"
              }, children: "MADE USING" }),
              /* @__PURE__ */ jsxRuntime2.jsx(
                "img",
                {
                  src: flourishLogo,
                  alt: "Flourish",
                  style: {
                    maxWidth: "400px",
                    width: "80vw",
                    height: "auto"
                  }
                }
              ),
              /* @__PURE__ */ jsxRuntime2.jsx("p", { style: {
                color: "#888",
                fontSize: "0.9rem",
                fontFamily: "sans-serif",
                marginTop: "3rem",
                fontStyle: "italic"
              }, children: "Click to continue" })
            ] }),
            /* @__PURE__ */ jsxRuntime2.jsx("style", { children: \`
                    @keyframes fadeIn {
                        from { opacity: 0; transform: translateY(10px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                \` })
          ]
        }
      );
    }
    return /* @__PURE__ */ jsxRuntime2.jsxs("div", { style: {
      width: "100vw",
      height: "100vh",
      background: "#000",
      overflow: "hidden"
    }, children: [
      /* @__PURE__ */ jsxRuntime2.jsx("style", { children: \`
                body {
                    user-select: none;
                    -webkit-user-select: none;
                    -moz-user-select: none;
                    -ms-user-select: none;
                }
                input, textarea, [contenteditable="true"] {
                    user-select: text;
                    -webkit-user-select: text;
                    -moz-user-select: text;
                    -ms-user-select: text;
                }
            \` }),
      /* @__PURE__ */ jsxRuntime2.jsx(ProjectProvider, { initialProject: project, children: /* @__PURE__ */ jsxRuntime2.jsx(LivePreview, { onClose: () => {
      }, hideCloseButton: true, autoStartMusic: true }) })
    ] });
  };
  const GameEngine2 = {
    /**
     * Mount the game to a DOM element
     * @param container - The DOM element to mount to
     * @param projectData - The VNProject data
     */
    mount: (container, projectData) => {
      if (!container) {
        throw new Error("Container element not found");
      }
      if (!projectData) {
        throw new Error("Project data is required");
      }
      const root = ReactDOM2.createRoot(container);
      root.render(
        /* @__PURE__ */ jsxRuntime2.jsx(React2.StrictMode, { children: /* @__PURE__ */ jsxRuntime2.jsx(StandalonePlayer, { project: projectData }) })
      );
    },
    /**
     * Get version information
     */
    version: "1.0.0",
    /**
     * Check if the engine is ready
     */
    isReady: () => {
      return typeof React2 !== "undefined" && typeof ReactDOM2 !== "undefined";
    }
  };
  if (typeof window !== "undefined") {
    window.GameEngine = GameEngine2;
  }
  exports.GameEngine = GameEngine2;
  exports.default = StandalonePlayer;
  Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
  return exports;
})({}, jsxRuntime, React, ReactDOM);
`;

export function getGameEngineCode(): string {
  return GAME_ENGINE_BUNDLE;
}
